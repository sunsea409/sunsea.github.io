<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字图像处理及应用（期末复习整理）</title>
      <link href="/2023/09/06/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/09/06/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数字图像处理及应用（期末复习整理）"><a href="#数字图像处理及应用（期末复习整理）" class="headerlink" title="数字图像处理及应用（期末复习整理） "></a><a href="https://www.cnblogs.com/wydxry/p/10962902.html">数字图像处理及应用（期末复习整理） </a></h1><h3 id="一、图像及其类型"><a href="#一、图像及其类型" class="headerlink" title="一、图像及其类型"></a>一、图像及其类型</h3><p><strong>图像（image）的定义是：</strong>在一般意义下，一幅图像是一个物体或对象（object）的另一种表示。亦即图像是其所表示物体或对象信息的一个直接描述和浓缩表示。简而言之，即图像是物体在平面坐标上的直观再现。一幅图像包含了所表示物体的描述信息和特征信息，或者说图像是与之对应的物体或抽象的一个真实表示，这个表示可以通过某些技术手段实现。</p><p><strong>数字图像处理（digital image processing）：</strong>又称为计算机图像处理，它是通过计算机对图像进行去除噪声、增强、变换、复原、分割、特征提取、识别等运算与处理。</p><p><strong>图像的分类：</strong></p><ul><li><strong>可见图像（visible image）：</strong>是指视觉系统可以直接看见的图像，这也是大多数人在日常生活中所见到的和所理解的图像，这一类图像一般通过照像、手工绘制等传统方法获得，通常计算机不能直接处理，但是经过数字化处理后可变为数字图像。</li><li><strong>物理图像（physical image）：</strong>所反映的是物体的电磁波辐射能，包括可见光和不可见光图像。</li><li><strong>数字图像（maths image）</strong>：指由连续函数或离散函数生成的抽象图像，其中离散函数所生成的图像就是计算机可以处理的数字图像。</li></ul><p>其他相关概念：</p><p><strong>计算机图形学（computer graphic）：</strong>是指利用计算机技术将概念或数学描述所表示的物体（非实物）图像进行处理和显示的过程。</p><p><strong>计算机视觉（computer vision）：</strong>是指利用计算机、传感器及相关设备模拟生物的视觉功能，主要目的是通过对传感器采集到的图像或视频信息进行处理，理解自然场景的二维或三维信息。</p><p><strong>噪声（noise）：</strong>一般是指加性的或乘性的非图像本源信息，即图像的污染信息。</p><p><strong>像素（pixel）：</strong>是指在由一个数字序列表示的图像中的一个最小单位，称为像素。</p><p><strong>对比度（contrast）：</strong>是指一幅图像中灰度反差的大小。</p><p><strong>采样密度（sampling density）：</strong>是指在图像上单位长度所包含的采样点数。</p><p><strong>放大率（magnification）：</strong>是指图像中物体与其所对应的实际景物中物体的大小的比例关系。</p><p><strong>数字化（digitizing）：</strong>是将一副图像从其原来的形式转换为数字形式的处理过程。</p><p><strong>扫描（scanning）：</strong>是按照一定的先后顺序对一幅图像进行遍历的过程。</p><p><strong>采样（sampling）：</strong>是指遍历过程中，在图像的每个像素位置上测量其灰度值，即亮度值。</p><p><strong>量化（quantization）：</strong>是指将采样得到的灰度值通过模/数转换等期间转换为离散的整数值。</p><hr><p> <strong>三、数字图像获取方法</strong></p><ul><li><strong>图像传感器：</strong>其作用是将真实场景的空间信息转换为图像信号，以数据文件的形式保存在存储介质上，并传输至计算机，它是图像处理不可或缺的通用设备。</li><li><strong>数字化扫描仪：</strong>其作用是将传统的可见光图像进过数字化处理转换为数字图像。</li><li><strong>应用各种光电转换设备直接得到数字图像。</strong></li><li><strong>合成图像：</strong>直接由二维离散数学函数生成数字图像。</li></ul><hr><h3 id="四、数据图像矩阵表示"><a href="#四、数据图像矩阵表示" class="headerlink" title="四、数据图像矩阵表示"></a>四、数据图像矩阵表示</h3><p><strong>数字图像在计算机中通常采用二维矩阵表示和存储</strong>，原始图像在水平方向和垂直方向被等间隔地分割成大小相同的小方格（grid），其中的每一个小方格称为像素点，简称为像素或像元（pixel）。像素是构成图像的最小基本单元，图像的每一像素都具有独立的属性，其中最基本的属性包括像元位置和灰度值两个属性。位置由像素所在的行和列的坐标值决定，通常以像素的位置坐标（x，y）表示，像素的灰度值即该像素对应的光学亮度值。</p><p><strong>数字图像的类型：</strong></p><ul><li><strong>二值图像：</strong>其灰度值只有0/1，其中灰度值0代表黑色，1代表白色。因此，二值图像所对应的的二维矩阵元素也只由0、1构成。</li><li><strong>灰度图像：</strong>一般指具有256级灰度值的数字图像，灰度图像只有灰度值二没有彩色。因此，每个像素都是介于黑色和白色之间的256中灰度中的一种。256级灰度值图像的数据类型为8位无符号整数，灰度值0代表纯黑色，255表示纯白色，0-255之间的数字由小到大表示从纯黑到纯白之间的过渡色。</li><li><strong>索引图像：</strong>它的文件结构与灰度图像和RGB图像文件不同，它既包括存放图像数据的二维矩阵，还包括一个颜色索引矩阵（称为MAP），因此称为索引图像，又称为映射图像。</li><li><strong>RGB彩色图像：</strong>又称为真彩色图像，RGB彩色图像与索引图像都是计算机可以处理的彩色图像。RGB彩色图像也同样是以R、G、B三原色的叠加来表示每个像素的颜色。与索引图像不同的是，RGB彩色图像每一个像素的颜色值（由RGB三原色表示）直接存放在图像矩阵中，不需要进行索引。</li></ul><hr><h3 id="五、图像的采样和量化"><a href="#五、图像的采样和量化" class="headerlink" title="五、图像的采样和量化"></a>五、图像的采样和量化</h3><p><strong>图像的采样：</strong>图像在二维空间上的离散化成为采样，具体地说，就是以空间上部分点的灰度值代表一幅图像，而这些点称为采样点。因为图像是一种二维分布的信息，因此，为了对它进行采样操作，需在垂直方向和水平方向分别进行采样。具体做法是：先沿垂直方向按一定间隔从上到下顺序地沿水平方向直线扫描，取出各水平线上灰度值的一维扫描信息。而后再对一维扫描信号按一定间隔采样得到离散信号，即先沿垂直方向采样，再沿水平方向采样，这样就完成了二维图形的数字化采样操作。对于运动图像，即时间域也是连续的图像，则虚线在时间轴上采样，再沿垂直方向采样，最后沿水平方向采样。</p><p><strong>图像的量化：</strong>模拟图像经过采样以后，在时间和空间上被离散化为像素，但采样所得到的像素值依然是连续量。量化的过程就是以离散的灰度值信息代替连续的模拟量灰度信息的过程，该过程是一对多的映射过程。量化可以分为线性量化和非线性量化两种方式。</p><ul><li><strong>线性量化：</strong>模拟图像的亮度值f是连续变化的数值，若f（x，y）的亮度值L的范围为[Lmin,Lmax]，则称区间[Lmin,Lmax]为灰度级范围（或色度范围）。若将灰度值区间[Lmin,Lmax]分成K个等间距的子区间，则称为线性量化或等间隔量化。量化过程中每个子区间对应一个亮度值qi，这样在灰度值范围[Lmin,Lmax]内就有K个亮度值对应，称为灰度级K。为方便计算机处理，灰度级K一般以2的整数次幂表示，一般取K=256，表示共有256个灰度级，此时位深度为8，一副128<em>128的彩色图像此时需要128</em>128<em>8</em>3位表示，即每一个像素实际上需要用24位表示。</li><li><strong>非线性量化：</strong>与线性量化的等间隔划分灰度区间相反，若将表示数字图像的灰度级范围分为不等间隔的子区间，则称为非线性量化或非均匀量化。</li></ul><p><strong>采样和量化的参数选择：</strong>并不是一味地提高采样点数和灰度级数量就可以获得高清晰度且高质量的数字图像，在确定采样和量化参数时，还应根据原始图像的性质与质量进行科学、合理的选择。</p><hr><h3 id="六、灰度直方图"><a href="#六、灰度直方图" class="headerlink" title="六、灰度直方图"></a>六、灰度直方图</h3><p>灰度直方图：是基于图像灰度值和像素统计分布的形象表示，它概括地表示了一副图像的灰度级信息。</p><p><strong>灰度直方图的定义：</strong>在数字图像处理中灰度直方图<strong>是灰度级的函数</strong>，<strong>它描述了图像中具有该灰度级的像素的个数，其横坐标是灰度级，纵坐标是该灰度出现的频率（像素的个数）</strong>。</p><p><strong>直方图的性质：</strong></p><ol><li>其是一幅图像中各像素灰度值出现次数或频数的统计结果，它只反映该图像中不同灰度值出现的频率，而不能反映某一灰度值像素所在的位置信息。</li><li>任一幅图像，都能唯一的确定一个与之对应的直方图，但不同的图像，可能有相同的直方图。也就是说，图像与直方图之间是一种多对一的映射关系。</li><li>由于直方图是对具有相同灰度值的像素统计计数得到的，若一幅图像由若干个子图像区域构成，那么个子区域直方图之和就等于原图像的直方图。</li></ol><p><strong>直方图的作用：</strong></p><ol><li><strong>数字化参数</strong></li><li><strong>选择边界阈值</strong></li><li><strong>计算机综合光密度</strong></li></ol><hr><h3 id="七、傅里叶变换（不是很懂）"><a href="#七、傅里叶变换（不是很懂）" class="headerlink" title="七、傅里叶变换（不是很懂）"></a>七、傅里叶变换（不是很懂）</h3><p>傅里叶变换是线性统计分析的有力工具，在数字图像处理与分析中，图像增强、图像恢复、图像编码与压缩、图像分析与描述等每一种处理手段和方法都可以应用图像变换方法。</p><hr><h3 id="八、离散余弦变换（不是很懂）"><a href="#八、离散余弦变换（不是很懂）" class="headerlink" title="八、离散余弦变换（不是很懂）"></a>八、离散余弦变换（不是很懂）</h3><p>DCT变换的全称是离散余弦变换，主要用于将数据或图像的压缩，能够将空域的信号转换到频域上，具有良好的去相关性的性能。</p><hr><h3 id="九、图像噪声"><a href="#九、图像噪声" class="headerlink" title="九、图像噪声"></a>九、图像噪声</h3><p> 对于数字图像处理而言，噪声是指图像中的非本源信息。图像中各种妨碍人们对其信息接受的因素即可称为图像噪声。</p><p>噪声的产生：图像数字化设备、电气系统和外界影响将使得图像噪声的产生不可避免。</p><p><strong>图像噪声的分类：内部噪声、外部噪声；平稳噪声、非平稳噪声；加性噪声、乘性噪声；白噪声、1/f噪声、三角噪声等。</strong></p><p>外部噪声：是指系统外部干扰以电磁波或经电源串进系统内部而引起的噪声，如电气设备、天体放电现象等引起的噪声。</p><p>内部噪声：是指成像系统本身原因引起的噪声。</p><p><strong>图像噪声的特点：</strong></p><ol><li><strong>随机性：</strong>即噪声在图像中是随机出现的。</li><li><strong>叠加性：</strong>噪声包括加性噪声、乘性噪声。生活中绝大多数的是加性噪声，在图像的串联传输系统中，各串联部件引起的噪声一般具有叠加效应，导致信噪比下降。</li><li><strong>噪声与图像之间具有相关性：</strong>通常情况下，摄像机的信号和噪声相关，明亮部分噪声小，黑暗部分噪声大。数字图像处理技术中存在的量化噪声与图像相位相关。</li></ol><hr><h3 id="十、图像增强处理"><a href="#十、图像增强处理" class="headerlink" title="十、图像增强处理"></a>十、图像增强处理</h3><p>图像增强处理分类：</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602161643533-206918214.jpg" alt="img"></p><hr><h3 id="十一、直方图的图像增强"><a href="#十一、直方图的图像增强" class="headerlink" title="十一、直方图的图像增强"></a>十一、直方图的图像增强</h3><p><strong>直方图均衡化：</strong>其做的处理是以累积分布函数为基础的直方图修改法。直方图均衡化的目的是将原始图像的直方图变为均衡分布的形式，将一非均匀灰度概率密度分布图像，通过寻求某周灰度变换，变成一副具有均匀概率分布的目的图像。</p><p>直方图均衡化实现可以参考之前的（直方图均衡化部分）：<a href="https://www.cnblogs.com/shixinzei/p/10902520.html">https://www.cnblogs.com/shixinzei/p/10902520.html</a></p><hr><h3 id="十二、空域滤波增强"><a href="#十二、空域滤波增强" class="headerlink" title="十二、空域滤波增强"></a>十二、空域滤波增强</h3><p><strong>图像的空间纹理信息</strong>可以反映图像中物体的<strong>位置、形状、大小</strong>等特征。</p><p>图像的空间纹理信息增强则可以通过<strong>空域滤波</strong>和<strong>频域滤波</strong>方法实现。</p><p>数字图像处理根据需要可以分别采用不同方法对<strong>图像的高频和低频特征信息</strong>进行增强。例如，公安系统在进行人像的比对查询时，就需要突出高频信息增强五官轮廓特征信息，这样不仅可以提高比对速度，还可以提升比对的准确率。</p><p><strong>高频滤波：增强图像的高频信息称为高频滤波它可以突出物体的边缘轮廓，从而起到锐化图像的作用，因此又称为锐化滤波器。</strong>根据频域分析理论，高频滤波能起到减弱或消除图像的低频分量、保留高频分量的作用。</p><p><strong>低频滤波：</strong>相应地，<strong>低通滤波则是指对图像的低频信息进行增强，又称为平滑滤波器。它可以实现图像的平滑处理，一般用于图像的噪声消除。</strong>平滑滤波可以减弱甚至消除图像的高频分量、保留低频分量。</p><hr><p> <strong>空域滤波模板：</strong></p><p>数字图像空域滤波的实现是应用模板卷积方法对每一像素点的领域进行处理完成的，它可分为<strong>线性</strong>和<strong>非线性</strong>两类空域滤波方法。</p><p>模板（template）运算方法是数字图像处理中常用的一种运算方式，图像的<strong>平滑、锐化、细化和边缘检测</strong>等都运用到模板操作。</p><p>模板操作实现了一种领域运算，即某个像素点的结果不仅和本像素灰度值有关，而且和其领域点的值有关。模板运算的数学含义是<strong>卷积（或互相关）运算</strong>。</p><p>卷积是一种用途很广的算法，可用卷积来完成各种处理变换。</p><p>以3<em>3领域f和3</em>3模板（又称为卷积核）卷积运算的处理过程为例，领域中的每一个像素点f1,f2,f3,…f9分别于模板中的每一个元素h1,h2,h3,…h9相乘，乘积求和所得的结果即为中心像素点的灰度值。</p><p><strong>模板或卷积的加权运算中，以下问题需要引起注意：</strong></p><ol><li><strong>图像边界问题。</strong>即在图像上移动模板至图像的边界时，在原图像中找不到与卷积核中的加权系数相对应的9个像素。一般的解决方法是：<strong>一种方法是忽略图像边界数据，即不处理图像的边缘像素；另一种方法是在图像四周复制原图像边界像素的值（或其他方法），</strong>从而达到平滑边界像素点的目的。实际应用中，多采用第一种方法。</li><li>卷积求和计算出来的像素值的动态范围问题，对此<strong>可以简单地将其值置为0或255，即小于零的置为0，大于255的置为255。</strong></li><li><strong>模板的大小与平滑效果直接相关</strong>，<strong>模板越大，平滑的效果越明显，但模板太大会造成图像的边缘信息的损失</strong>，模板的大小要在保证消除噪声的前提下尽可能保持图像的边缘信息。模板大小一般为技术，且不超过11*11。</li></ol><h3 id="线性平滑滤波："><a href="#线性平滑滤波：" class="headerlink" title="线性平滑滤波："></a>线性平滑滤波：</h3><p>各种线性平滑滤波方法一般都基于模板卷积进行运算，<strong>平滑滤波一般用于消除图像中的随机噪声，起到图像平滑的作</strong>用。线性平滑滤波的<strong>作用是对图像的高频分量进行削弱或消除</strong>，<strong>增强图像的低频分量</strong>。平滑滤波器的设计比较简单，若模板各系数取不同的值，就可以得到不同的平滑滤波器。</p><p>常用的平滑滤波方法是<strong>领域均值滤波法和中值滤波法</strong>，其中<strong>领域平均法是线性运算</strong>，而<strong>中值滤波法是非线性运算</strong>。</p><p><strong>领域平均法：</strong>领域平均滤波法是将一个像素点及其领域中的所有像素点的平均值赋给输出图像中相应的像素点，从而达到平滑的目的，又称为均值滤波法。最简单的领域平均法是所有模板系数都去相同的值，例如，取模板系数为1，常用的模板为3<em>3和5</em>5的两种模板类型，如下图所示（）：</p><p>3*3模板如下：</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602230900840-270811007.png" alt="img">5*5模板如下：</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602231133828-386304274.png" alt="img"></p><p><strong>领域平均法实例：</strong></p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602172045963-915937202.jpg" alt="img"></p><p><strong>*\</strong>*领域平均法**实现代码（matlab）如下：*<em>*</em></p><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> 1 %Mean(Averaging) Filter<br> 2 clear;clc;<br> 3 i=imread(&#x27;1.png&#x27;);<br> 4 i=im2double(i);<br> 5 g=rgb2gray(i);<br> 6 g = imnoise(g,&#x27;salt &amp; pepper&#x27;,0.08);<br> 7 b=g;<br> 8 s=size(g);<br> 9 for x=2:s(1)-1<br>10     for y=2:s(2)-1<br>11         b(x,y)=(g(x+1,y)+g(x-1,y)+g(x+1,y+1)+g(x,y+1)+g(x,y-1)+g(x+1,y-1)+g(x-1,y-1)+g(x,y)+g(x-1,y+1))/9;<br>12     end<br>13 end<br>14 subplot(1,3,1); imshow(i);<br>15 subplot(1,3,2); imshow(g);<br>16 subplot(1,3,3); imshow(b);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>测试结果如下：（最左边的图像是原图像，中间的图像是加了噪声后的图像，最右边是用领域平均法处理后的图像）</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602180451008-50038567.png" alt="img"></p><hr><p><strong>加权平均法：</strong>领域平均法认为被处理像素与领域内其他像素点的作用相等，因此，模板的系数完全相等。加权均值滤波法认为，对于被处理的像素点，其领域内像素的贡献是不一样的，离被处理像素距离近者，其贡献大，因此，其模板的系数大小不完全相等。以3*3模板为例，常用的加权平均模板矩阵为：</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602230126290-1662899513.png" alt="img"></p><p><strong>高斯滤波：</strong>实质上是根据高斯函数计算出来的一种滤波模板，其<strong>用途为对图像信号进行平滑消噪处理</strong>。图像处理的后期应用，其噪声是一个很重要的问题，因为误差会累积传递，高斯平滑滤波器对于抑制服从正态分布的噪声非常有效，用于得到信噪比SNR较高的图像（反映真实信号）。图像处理中，高斯滤波主要可以用两种方法实现。<strong>一种方法是：离散化窗口滑窗卷积，另一种方法是通过傅里叶变换。</strong>一般采用第一种离散化窗口卷积形式实现，5*5的高斯模板为：　　</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602230556430-252795534.png" alt="img"></p><hr><h3 id="非线性平滑滤波："><a href="#非线性平滑滤波：" class="headerlink" title="非线性平滑滤波："></a>非线性平滑滤波：</h3><p>虽然基于模板的线性滤波方法简便易行，但对于既需要消除噪声又要保持好的图像细节时，其效果并不理想，二非线性滤波在这方面具有一定的优势。</p><p>非线性滤波最经典使用的方法是基于模板的统计排序滤波，主要包括<strong>中值滤波、最大值滤波和最小值滤波</strong>三种方法，该滤波方法基于滤波器所在图像区域中像素的排序，由排序结果决定的值代替中心像素的值。</p><p><strong>中值滤波：</strong></p><p>尽管领域平均滤波法可以起到平滑图像的作用，但在消除噪声的同时，会使图像中的一些细节变得模糊。<strong>中值滤波法在消除噪声的同时还能保持图像中的细节部分，防止图像边缘部分模糊。与领域平均法不同，中值滤波是一种非线性滤波，它将领域内所有像素点值从小到大排序，取中间值作为中心像素点的输出值。</strong>采用中值滤波，在一定的条件下，可以克服数字图像细节模糊的问题。<strong>中值滤波的原理是利用一个奇数点的移动窗口（3*3或5*5窗口），将窗口中心点的值用窗口各点的中间值代替。\</strong>计算公式为：gij=Med{xij}*<em>*</em></p><p><strong>中值滤波实现代码（matlab）如下：</strong></p><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> 1 %Median filtering<br> 2 clear;clc;<br> 3 I=imread(&#x27;1.png&#x27;);<br> 4 I=rgb2gray(I);<br> 5 [r c]=size(I);<br> 6 I = imnoise(I,&#x27;salt &amp; pepper&#x27;,0.02);%加入噪声<br> 7 for x=2: r-1<br> 8     for y=2: c-1<br> 9         w=I(x-1:x+1,y-1:y+1);<br>10         g=sort(w);%3*3窗口内元素排序<br>11         f(x,y)=median(median(g));%取中值<br>12     end<br>13 end<br>14 imshow(I,[]);<br>15 figure;imshow(f,[]);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>测试结果如下：（Figure1为加了噪声的图像，Figure2为进行中值滤波处理后的图像，效果还是比较明显）</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602180043697-1898855531.png" alt="img"></p><p><strong>最大值滤波：</strong></p><p>最大值滤波法的实现过程与中值滤波类似，不同之处是用像素领域内的最大值代替被处理像素的灰度值实现滤波。<strong>其主要用途是寻找最亮点。</strong></p><p><strong>计算公式为：gij=Max{xij}</strong></p><p><strong>最小值滤波：</strong></p><p>最小值滤波法的实现是用像素领域内的最小值代替被处理像素的灰度值实现滤波。<strong>其主要用途是寻找最暗点。</strong></p><p><strong>计算公式为：gij=Min{xij}</strong></p><hr><h3 id="锐化滤波器"><a href="#锐化滤波器" class="headerlink" title="锐化滤波器"></a>锐化滤波器</h3><ol><li><strong>梯度法</strong></li><li><strong>拉普拉斯算子</strong></li><li><strong><em>\</em>定向滤波**</strong></li></ol><p><strong><em>\</em>梯度法测试代码（matlab）：**</strong></p><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> 1 %Gradient Operators<br> 2 clear;clc;<br> 3 I=imread(&#x27;1.png&#x27;);<br> 4 I=rgb2gray(I);<br> 5 I=imresize(I,[256 256]);<br> 6 [r c]=size(I);    <br> 7 LP=[-1 -2 -1; <br> 8     0 0 0; <br> 9     -1 -2 -1];    % Gradient with repect to Horizontal<br>10 LN=[-1 0 1; <br>11     -2 0 2; <br>12     -1 0 1];        % Gradient with repect to Vertical<br>13 for x=2: r-1<br>14     for y=2: c-1<br>15         w=I(x-1:x+1,y-1:y+1);<br>16         gi=double(w)+double(LP);<br>17         gp(x,y)=gi(2,2);        %Gradient with repect to Horizontal<br>18         g=imsubtract(double(w),double(LN));<br>19         gn(x,y)=g(2,2);         % Gradient with repect to Vertical<br>20         <br>21     end<br>22 end<br>23 figure;imshow(I,[]);title(&#x27;orignal image&#x27;);<br>24 figure;imshow(gp,[]);title(&#x27;horiz grad Image&#x27;);<br>25 figure;imshow(gn,[]);title(&#x27;ver grad Image&#x27;);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong><em>\</em>拉普拉斯算子测试代码（matlab）：**</strong></p><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> 1 % Laplacian program with respect to +ve and -ve<br> 2 clear;clc;<br> 3 I=imread(&#x27;1.png&#x27;);<br> 4 I=rgb2gray(I);<br> 5 I=imresize(I,[256 256]);<br> 6 %PSF=fspecial(&#x27;gaussian&#x27;,5,3);<br> 7 %I=imfilter(I,PSF);<br> 8 [r c]=size(I);    <br> 9 LP=[-1 -1 -1; <br>10     -1 4 -1; <br>11     -1 -1 -1];    % Laplacian with repect to +ve window<br>12 LN=[1 1 1; <br>13     1 -4 1; <br>14     1 1 1];        % Laplacian with repect to -ve window<br>15 for x=2: r-1<br>16     for y=2: c-1<br>17         w=I(x-1:x+1,y-1:y+1);<br>18         gi=double(w)+double(LP);<br>19         gp(x,y)=gi(2,2);        % Laplacian with repect to +ve<br>20         g=imsubtract(double(w),double(LN));<br>21         gn(x,y)=g(2,2);         % Laplacian with repect to +ve<br>22         <br>23     end<br>24 end<br>25 figure;imshow(I,[]);title(&#x27;orignal image&#x27;);<br>26 figure;imshow(gp,[]);title(&#x27;+ve Laplacian Image&#x27;);<br>27 figure;imshow(gn,[]);title(&#x27;-ve Laplacian Image&#x27;);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>定向滤波测试代码（matlab）：</p><p>先空着。。。</p><hr><h2 id="十三、低通滤波"><a href="#十三、低通滤波" class="headerlink" title="十三、低通滤波"></a>十三、低通滤波</h2><p>图像从空间域变换到频率域后，其低频分量对应图像中的灰度值变化比较缓慢的区域，而高频分量则表示图像中物体得边缘和随机噪声信息。<strong>低通滤波功能是通过低通滤波器函数H减弱或抑制高频分量，保留低频分量。</strong>因此，低通滤波与空域中的平滑滤波器在功能上是一样的，<strong>可以消除图像中的随机噪声、削弱边缘效应，起到平滑图像的作用。</strong></p><p><strong>低通滤波器的类型：</strong></p><ol><li><strong>理想低通滤波器</strong></li><li><strong>巴特沃斯低通滤波器</strong></li><li><strong>指数低通滤波器</strong></li><li><strong>梯形低通滤波器</strong></li></ol><hr><h2 id="十四、高通滤波"><a href="#十四、高通滤波" class="headerlink" title="十四、高通滤波"></a>十四、高通滤波</h2><p>图像中物体的边缘及其他灰度变化较快的区域与图像的高频信息有关，因此<strong>可以利用高通滤波器可以对图像的边缘信息进行增强，起到锐化图像的作用</strong>。</p><p><strong>高通滤波器的类型：</strong></p><ol><li><strong>理想高通滤波器</strong></li><li><strong>巴特沃斯高通滤波器</strong></li><li><strong>指数高通滤波器</strong></li><li><strong>梯形高通滤波器</strong></li></ol><hr><h2 id="十五、全彩色图像处理"><a href="#十五、全彩色图像处理" class="headerlink" title="十五、全彩色图像处理"></a>十五、全彩色图像处理</h2><p>自然界的颜色是多种多样的、丰富多彩的，<strong>能真实反映自然物体真实色彩的图像叫真彩色图像或全彩色图像</strong>，若彩色图像的<strong>单通道位深度为8位</strong>，则<strong>真彩色图像是指24位RGB图像</strong>。</p><p><strong>处理方法分两类：</strong></p><ol><li><strong>合成处理法：即将RGB图像分解为R、G、B三个波段的图像分量，分别对R分量、G分量、B分量的图像进行处理，处理之后合成处理后的彩色图像。</strong></li><li><strong>直接处理法：指直接处理每一个彩色像素，即每一个像素是三个三维分量,令c表示RGB图像任意像素的向量，则有c=[CR,CG,CB**</strong>]’=[R,G,B]’;**</li></ol><h3 id="彩色图像直方图增强"><a href="#彩色图像直方图增强" class="headerlink" title="彩色图像直方图增强"></a>彩色图像直方图增强</h3><p>彩色图像直方图均衡化的作用是扩展输入图像各分量灰度值的动态范围，提高图像的对比度和亮度。</p><h3 id="彩色图像去噪"><a href="#彩色图像去噪" class="headerlink" title="彩色图像去噪"></a><strong>彩色图像去噪</strong></h3><p>彩色图像去噪基础理论和灰度图像去噪方法类似，不同之处是需按R、G、B三分量分别进行滤波消噪，在彩色图像消噪中，空域滤波和频域滤波方法都可以根据情况选择采用。</p><h3 id="彩色频域处理"><a href="#彩色频域处理" class="headerlink" title="彩色频域处理"></a>彩色频域处理</h3><p>彩色图像频域滤波的基本原理是：先将RGB彩色图像的R、G、B三个分量分别进行傅里叶变换，并根据各分量的特点和图像处理的目的，对各分量分别选择低通、高通、带通、或带阻滤波，以及对各分量信息进行其他处理。</p><p><strong>以上的实际操作代码可以参考之前的图像处理实现部分：</strong><a href="https://www.cnblogs.com/shixinzei/p/10902520.html">https://www.cnblogs.com/shixinzei/p/10902520.html</a></p><hr><h2 id="十六、无约束复原技术（不是很懂）"><a href="#十六、无约束复原技术（不是很懂）" class="headerlink" title="十六、无约束复原技术（不是很懂）"></a>十六、无约束复原技术（不是很懂）</h2><p>无约束复原法就是在已经给定退化图像g(x,y)的条件下，图像复原完全取决于对退化系统h(x,y)及噪声n(x,y)的了解，从而估计出原始图像f(x,y)。</p><hr><h2 id="十七、逆滤波器（不是很懂）"><a href="#十七、逆滤波器（不是很懂）" class="headerlink" title="十七、逆滤波器（不是很懂）"></a>十七、逆滤波器（不是很懂）</h2><p>逆滤波复原法是无约束复原法的一种，又称为反向滤波复原法或去模糊。逆滤波是通过变换到频率进行滤波的，属于频域图像复原法。逆滤波复原法的基本原理是根据图像退化原因进行反向滤波。</p><hr><h2 id="十八、几何畸变校正"><a href="#十八、几何畸变校正" class="headerlink" title="十八、几何畸变校正"></a>十八、几何畸变校正</h2><p>数字图像在获取过程中常常由于成像系统的几何非线性误差，导致图像产生几何失真。例如，成像图与原景物图像相比可能出现了比例失调，甚至扭曲现象，这类图退化现象一般称为图像的几何畸变。<strong>几何畸变校正的目的是需对失真的图像进行精确的几何校正，通常是先确定一幅图像为基准，然后去校正另一幅图像的几何形状。</strong></p><p>几何畸变校正一般分两步进行：<strong>第一步是图像空间坐标的变换；第二步是重新确定在校正空间各像素点的取值。</strong></p><ol><li><strong>空间几何坐标变换</strong></li><li><strong>三角形线性法</strong></li><li><strong>灰度值的确定</strong></li></ol><hr><h2 id="十九、盲目图像复原"><a href="#十九、盲目图像复原" class="headerlink" title="十九、盲目图像复原"></a>十九、盲目图像复原</h2><p><strong>盲目图像复原法是指在没有图像退化先验知识、对退化系统了解不足的条件下，通过观察退化图像的多个图像并以某种特殊方式抽出退化信息，进行图像复原的方法。</strong></p><p>在这种条件下，具有加噪声的模糊图像复原方法一般有：</p><ol><li><strong>直接测量法</strong></li><li><strong>简介估计法</strong></li></ol><hr><h2 id="二十、图像编码的基本原理"><a href="#二十、图像编码的基本原理" class="headerlink" title="二十、图像编码的基本原理"></a>二十、图像编码的基本原理</h2><p>编码是信息科学的经典研究课题，应用计算机进行图像处理必须首先进行图像数字化，而图像数字化的关键是编码。50年来,图像编码技术得到了快速的发展,已经有多种成熟的编码方法得到了广泛应用,特别是所谓的第一代编码更是如此。 而且,随着多媒体技术的发展,已有若干编码标准由ITU-T制定出来，如JPEG、H.261、H. 263、MPEG-1、MPEG-2、MPEG-4、MPEG 7、JBIG等。数据压缩编码方法经过几十年的发展,针对不同的原始数据的特点如文本、声音、图像、视频、动画已研究出了不同的编码方法。</p><p><strong>图像编码也称图像压缩：是指在保证一定质量（信噪比或主观评价）的条件下，按照一定的规则、以较少比特数表示源图像的一种方法。</strong></p><p><strong>图像中的信息冗余：</strong></p><ol><li><strong>视觉冗余</strong></li><li><strong>空间冗余</strong></li><li><strong>时间冗余</strong></li><li><strong>信息熵冗余</strong></li><li><strong>结构冗余</strong></li><li><strong>知识冗余</strong></li></ol><p><strong>图像编码方法分类：</strong></p><p><strong>熵编码：</strong></p><ol><li><strong>霍夫曼编码</strong></li><li><strong>算术编码</strong></li><li><strong>RLE编码</strong></li></ol><p><strong>预测编码：</strong></p><ol><li><strong>DPCM编码</strong></li><li><strong>运动补偿法</strong></li></ol><p><strong>变换编码：</strong></p><ol><li><strong>DCT变换编码</strong></li><li><strong>DFT变换编码</strong></li><li><strong>小波变换编码</strong></li></ol><p><strong>混合编码：</strong></p><ol><li><strong>JPEG编码</strong></li><li><strong>MPEG编码</strong></li></ol><hr><h2 id="二十一、图像统计编码"><a href="#二十一、图像统计编码" class="headerlink" title="二十一、图像统计编码"></a>二十一、图像统计编码</h2><p><strong>统计编码又称为熵编码，它是建立在图像统计特征基础之上的数据压缩方法</strong>，根据香农的观点，信息冗余来自信源数据本身的相关性和信源内事件的概率分布不均匀性，只要找到去除相关性和改变概率分布不均匀的方法，也就找到了信源数据的统计编码方法。</p><p><strong>变长最佳编码原理：在变长编码中，对出现概率大的符号编以短码字，对出现概率小的符号编以长码字。</strong></p><p><strong>霍夫曼编码：</strong>有时又称为最佳编码，完全依据信源字符出现的概率来构造其码字，对出现概率大的字符使用较短的码字，而对出现概率低的字符使用较长的码字，从而达到压缩数据的目的，最初主要用于文本文件压缩。</p><p>简单的霍夫曼树算法参考链接：<a href="https://www.cnblogs.com/shixinzei/p/10683774.html">https://www.cnblogs.com/shixinzei/p/10683774.html</a></p><p><strong>还有其他的编码（不在赘述）：</strong></p><ol><li><strong>香农-范诺编码</strong></li><li><strong>行程长度编码</strong></li><li><strong>算术编码</strong></li><li><strong>位平面编码</strong></li><li><strong>灰度码分解</strong></li></ol><hr><h2 id="二十二、预测编码"><a href="#二十二、预测编码" class="headerlink" title="二十二、预测编码"></a>二十二、预测编码</h2><p><strong>预测编码是指依据某一模型，根据以往的样本值对于新样本进行预测，然后将样本的实际值与预测值相减得到一个误差值，对这一误差值进行编码。</strong>如果模型足够好且样本序列在时间和空间上存在较强的相关性，那么误差信号的幅度将远远小于信源原始信号，从而可以用较少的电平量对其差值量化得到较大的数据压缩结果。</p><p><strong>预测编码的类型：</strong></p><ol><li><strong>线性预测</strong></li><li><strong>非线性预测</strong></li></ol><hr><h2 id="二十三、图像分割的基本概念"><a href="#二十三、图像分割的基本概念" class="headerlink" title="二十三、图像分割的基本概念"></a>二十三、图像分割的基本概念</h2><p>图像分割的目的是将图像划分为若干具有一定意义的或一定目的的子区域。可以逐个像素点为基础研究图像分割，也可以利用在规定邻域中的某些图像信息进行分割。分割的依据一般建立在相似性和非连续性两个基本概念的基础上。</p><p><strong>图像分割的基本原理：</strong></p><p>图像分割是根据图像的组成结构和应用需求将图像划分成若干个互不相交的子区域的过程，这些子区域是某种意义下具有共同属性的像素的连通集合。</p><p><strong>图像分割的方法：</strong></p><ol><li><strong>基于阈值的分割方法</strong></li><li><strong>基于区域的分割方法</strong></li><li><strong>基于边缘的分割方法</strong></li></ol><hr><h2 id="二十四、阈值分割法"><a href="#二十四、阈值分割法" class="headerlink" title="二十四、阈值分割法"></a>二十四、阈值分割法</h2><p>阈值分割是一种常用的、传统的图像分割方法，实现简单、计算量小、性能比较稳定，目前在图像分割中早已成为一种基本方法，得到广泛应用。</p><p><strong>常用的图像分割方法：是把图像灰度分为不同的等级，然后用设置灰度门限值（阈值）的方法确定有意义的区域或分割物体的边界。常用的阈值化处理就是图像的二值化处理，即选择一阈值，将图像转换为黑白二值图像，用于图像分割及边缘提取等处理之中。</strong></p><p>图像阈值化处理的变换函数形式为：</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602210803111-114276364.png" alt="img"></p><p>显然，图像阈值化处理是一种阶梯函数，属于图像灰度级的非线性运算。它的功能是由用户指定一个阈值，<strong>如果图像中某个像素的灰度值大于该阈值，则将该像素的灰度值置为255，否则将其灰度值置为0.</strong></p><p><strong>阈值分割的优点：计算简单、运算效率高、速度快。</strong></p><p><strong>阈值分割法代码实现（matlab）如下：</strong></p><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> 1 clear;clc;<br> 2 r=imread(&#x27;2.png&#x27;);<br> 3 r=rgb2gray(r);<br> 4 t=130;<br> 5 [m n]=size(r);<br> 6 for i=1:m<br> 7     for j=1:n<br> 8         if r(i,j)&lt;=t<br> 9             s(i,j)=0;<br>10         else<br>11             s(i,j)=255;<br>12         end<br>13     end<br>14 end<br>15 hold on<br>16 subplot(1,2,1);imshow(s);<br>17 subplot(1,2,2);imshow(r);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>测试结果如下（右图为原图像的灰度图，左图为阈值T为130阈值分割处理后的图像）：</p><p><img src="https://img2018.cnblogs.com/blog/1076860/201906/1076860-20190602212814965-411234350.png" alt="img"></p><hr><h2 id="二十五、区域分割"><a href="#二十五、区域分割" class="headerlink" title="二十五、区域分割"></a>二十五、区域分割</h2><p>基于区域的图像分割方法主要包括<strong>区域生长</strong>和<strong>区域分裂与合并</strong>两种典型的方法。</p><ul><li><strong>区域生长法是</strong>从单个像素出发，逐渐合并周围像素，最后形成所需要的分割结果。</li><li><strong>分裂与合并法</strong>是从整幅图像出发，逐渐分裂或合并，会后形成所需要的分割结果。</li></ul><hr><h2 id="二十六、边缘检测的基本原理"><a href="#二十六、边缘检测的基本原理" class="headerlink" title="二十六、边缘检测的基本原理"></a>二十六、边缘检测的基本原理</h2><p>图像分割的另一种重要途径就是通过<strong>边缘检测</strong>，即检测灰度级或者一幅图像中结构具有突变的地方，表明一个区域的终结，也是另一个区域的开始。这种不连续性称为边缘。图像内不同物体灰度不同，一般有明显边缘，利用此特征可以分割图像。</p><p>图像内边缘处像素的灰度值不连续，这种不连续性可通过求导数检测。对于阶跃类型的边缘，其位置对应一阶导数的极值点，对应二阶导数的过零点。因此常用微分算子进行边缘检测。<strong>常用的一阶微分算子有Robert算子和Sobel算子，二阶微分算子有Laplace算子和Kirsh算子等</strong>。实际应用时各种微分算子通常用模板来实现，即微分运算是利用模板和图像卷积实现的。这些算子对噪声敏感，只适合于噪声较小不太复杂的图像。</p><p>具体实现以及测试可以参考之前的博文（边缘检测部分）： <a href="https://www.cnblogs.com/shixinzei/p/10899102.html">https://www.cnblogs.com/shixinzei/p/10899102.html</a></p><hr><h2 id="二十七、几何特征"><a href="#二十七、几何特征" class="headerlink" title="二十七、几何特征"></a>二十七、几何特征</h2><p><strong>图像的几何特征是指图像中物体的位置、方向、周长和面积等方面的特征。</strong>提取图像几何特征之前，一般要对图像进行分割和二值化处理。二值图像只有0和1两个灰度级，便于获取、分析和处理，虽然二值图像只能给出物体的轮廓信息，但在图像分析和计算机视觉中，二值图像及其几何特征特别具有价值，可用来完成分类、检验、定位、轨迹跟踪等任务。</p><hr><h2 id="二十八、颜色特征"><a href="#二十八、颜色特征" class="headerlink" title="二十八、颜色特征"></a>二十八、颜色特征</h2><p><strong>颜色特征是图像检索、图像识别与分类中应用广泛的重要视觉特征，主要原因在于颜色往往和图像中所包含的物体或场景相关。</strong>与其他视觉特征相比，颜色特征对图像自身的某些几何形状特性，如尺寸、方向、视角的依赖性较小，从而具有较高的鲁棒性。颜色特征是一种全局特征，描述了图像或图像内区域所对应的景物的表面性质。</p><p>颜色直方图是最常用的表达颜色特征的方法，其优点是不受图像旋转和平移变化的影响，基于归一化的直方图还可不受图像尺寸变化的影响，其缺点是没有表达出颜色空间分布的信息。<strong>颜色特征常用的特征提取与匹配方法主要包括颜色直方图、颜色集、颜色炬、颜色聚合向量和颜色相关图</strong>。</p><p><strong>特别提一下，基于HSV空间的颜色直方图也常常被采用，它的三个分量分别代表色彩（hue）、饱和度（saturation）和值（value）。</strong></p><hr><h2 id="二十九、纹理特征"><a href="#二十九、纹理特征" class="headerlink" title="二十九、纹理特征"></a>二十九、纹理特征</h2><p>纹理图像在局部区域内可能呈现不规则性，但整体上则表现出一定的规律性，其灰度分布往往表现出某种周期性。纹理图像所表现出的这种特有的性质称为纹理。纹理最初是指纤维物外观，纹理图像在很大范围内没有重大细节变化，在这些区域内图像往往显示出重复性结构。有时，物体纹理上与周围背景和其他物体有区别，这是，图像分割应以纹理为基础。</p><p><strong>一般来说，纹理是由许多相互接近的、互相交织的元素构成，它们具有周期性。纹理在一定程度上反映了一个区域中像素灰度级的空间分布的属性。</strong></p><p><strong>纹理分析常用的方法有：</strong></p><ul><li><strong>统计法</strong></li><li><strong>自相关函数法</strong></li><li><strong>傅里叶频谱法</strong></li><li><strong>联合概率矩阵法</strong></li><li><strong>句法结构法</strong></li></ul><hr><h2 id="三十、骨架的概念"><a href="#三十、骨架的概念" class="headerlink" title="三十、骨架的概念"></a>三十、骨架的概念</h2><p><strong>图像骨架提取是指提取目标在图像中的中心像素轮廓，即以物体的对称中心为目标，对目标进行细化，细化后的目标通常为单层像素宽度。</strong></p><p>图像细化和骨架提取的目的都是为了减小像素的连通区，一般情况下这些运算都是不可逆的。</p><p>通俗的说，骨架化运算是指将目标区域变为条形骨架的算法。骨架或细化的概念主要是针对二值图而言。从某种意义上，所谓骨架，可以理解为图像的中轴。</p><p><strong>骨架获取的方法：</strong></p><ol><li><strong>烈火燃烧</strong></li><li><strong>基于最大圆盘</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
            <tag> 期末复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="/2023/08/11/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2023/08/11/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="一-巴什博奕（Bash-Game）："><a href="#一-巴什博奕（Bash-Game）：" class="headerlink" title="一.  巴什博奕（Bash Game）："></a>一.  巴什博奕（Bash Game）：</h2><p>  A和B一块报数，每人每次报最少1个，最多报4个，看谁先报到30。这应该是最古老的关于巴什博奕的游戏了吧。</p><p>其实如果知道原理，这游戏一点运气成分都没有，只和先手后手有关，比如第一次报数，A报k个数，那么B报5-k个数，那么B报数之后问题就变为，A和B一块报数，看谁先报到25了，进而变为20,15,10,5，当到5的时候，不管A怎么报数，最后一个数肯定是B报的，可以看出，作为后手的B在个游戏中是不会输的。</p><p>那么如果我们要报n个数，每次最少报一个，最多报m个，我们可以找到这么一个整数k和r，使n=k*(m+1)+r，代入上面的例子我们就可以知道，如果r=0，那么先手必败；否则，先手必胜。</p><p>巴什博奕：只有一堆n个物品，两个人轮流从中取物，规定每次最少取一个，最多取m个，最后取光者为胜。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int n,m;<br>    while(cin&gt;&gt;n&gt;&gt;m)<br>      if(n%(m+1)==0)  cout&lt;&lt;&quot;后手必胜&quot;&lt;&lt;endl;<br>      else cout&lt;&lt;&quot;先手必胜&quot;&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题有：HDU4764  Stone：</p><p>题目大意：Tang和Jiang轮流写数字，Tang先写，每次写的数x满足1&lt;=x&lt;=k，Jiang每次写的数y满足1&lt;=y-x&lt;=k，谁先写到不小于n的数算输。</p><p>结论：r=(n-1)%(k+1)，r=0时Jiang胜，否则Tang胜。</p><h2 id="二-威佐夫博弈（Wythoff-Game）："><a href="#二-威佐夫博弈（Wythoff-Game）：" class="headerlink" title="二.  威佐夫博弈（Wythoff Game）："></a>二.  威佐夫博弈（Wythoff Game）：</h2><p>有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。</p><p>直接说结论了，若两堆物品的初始值为（x，y），且x&lt;y，则另z=y-x；</p><p>记w=(int)[((sqrt(5)+1)/2)*z ]；</p><p>若w=x，则先手必败，否则先手必胜。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int n1,n2,temp;<br>    while(cin&gt;&gt;n1&gt;&gt;n2)<br>    &#123;<br>        if(n1&gt;n2)  swap(n1,n2);<br>        temp=floor((n2-n1)*(1+sqrt(5.0))/2.0);<br>        if(temp==n1) cout&lt;&lt;&quot;后手必胜&quot;&lt;&lt;endl;<br>        else cout&lt;&lt;&quot;先手必胜&quot;&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-尼姆博弈（Nimm-Game）："><a href="#三-尼姆博弈（Nimm-Game）：" class="headerlink" title="三.  尼姆博弈（Nimm Game）："></a>三.  尼姆博弈（Nimm Game）：</h2><p>尼姆博弈指的是这样一个博弈游戏：有任意堆物品，每堆物品的个数是任意的，双方轮流从中取物品，每一次只能从一堆物品中取部分或全部物品，最少取一件，取到最后一件物品的人获胜。</p><p>结论就是：把每堆物品数全部异或起来，如果得到的值为0，那么先手必败，否则先手必胜。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int n,ans,temp;<br>    while(cin&gt;&gt;n)<br>    &#123;<br>        temp=0;<br>        for(int i=0;i&lt;n;i++)<br>        &#123;<br>            cin&gt;&gt;ans;<br>            temp^=ans;<br>        &#125;<br>        if(temp==0)  cout&lt;&lt;&quot;后手必胜&quot;&lt;&lt;endl;<br>        else cout&lt;&lt;&quot;先手必胜&quot;&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-斐波那契博弈："><a href="#四-斐波那契博弈：" class="headerlink" title="四.  斐波那契博弈："></a>四.  斐波那契博弈：</h2><p>有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。</p><p>结论是：先手胜当且仅当n不是斐波那契数（n为物品总数）</p><p>如HDU2516</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;iostream&gt;  <br>#include &lt;string.h&gt;  <br>#include &lt;stdio.h&gt;  <br>using namespace std;  <br>const int N = 55;    <br>int f[N];   <br>void Init()  <br>&#123;  <br>    f[0] = f[1] = 1;  <br>    for(int i=2;i&lt;N;i++)  <br>        f[i] = f[i-1] + f[i-2];  <br>&#125;    <br>int main()  <br>&#123;  <br>    Init();  <br>    int n;  <br>    while(cin&gt;&gt;n)  <br>    &#123;  <br>        if(n == 0) break;  <br>        bool flag = 0;  <br>        for(int i=0;i&lt;N;i++)  <br>        &#123;  <br>            if(f[i] == n)  <br>            &#123;  <br>                flag = 1;  <br>                break;  <br>            &#125;  <br>        &#125;  <br>        if(flag) puts(&quot;Second win&quot;);  <br>        else     puts(&quot;First win&quot;);  <br>    &#125;  <br>   return 0;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2023/08/11/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2023/08/11/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="邻接表的构造和深广优先遍历"><a href="#邻接表的构造和深广优先遍历" class="headerlink" title="邻接表的构造和深广优先遍历"></a>邻接表的构造和深广优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],e[N],ne[N],idx,st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx]=b,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    idx=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-comment">//..</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些初始化操作"><a href="#一些初始化操作" class="headerlink" title="一些初始化操作"></a>一些初始化操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>st[u]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//st[]==true则表示st[u]这个点已经被遍历过了</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br> <span class="hljs-type">int</span> j=e[i];<br> <span class="hljs-keyword">if</span>(!st[j])&#123;<br> <span class="hljs-built_in">dfs</span>(j);<br> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="深度优先遍历的模板"><a href="#深度优先遍历的模板" class="headerlink" title="深度优先遍历的模板"></a>深度优先遍历的模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br><span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:e[p])&#123;<br><span class="hljs-keyword">if</span>(it==q)&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-type">int</span> rres=<span class="hljs-built_in">dfs</span>(it,p);<br>res+=rres;<br>&#125;<br>siz[p]=res;<br><span class="hljs-comment">//cout&lt;&lt;res&lt;&lt;&quot;_&quot;&lt;&lt;endl;</span><br><span class="hljs-comment">//在这里就可以直接判断子节点数的一些性质了 </span><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//dfs求子树的子节点数</span><br><br></code></pre></td></tr></table></figure><h3 id="求节点的子树的节点和"><a href="#求节点的子树的节点和" class="headerlink" title="求节点的子树的节点和"></a>求节点的子树的节点和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br><span class="hljs-type">int</span> res=e[p].second;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:e[p])&#123;<br><span class="hljs-keyword">if</span>(it==q)&#123;<br><span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> rres=<span class="hljs-built_in">dfs</span>(it,p);<br>        res+=rres;<br>    &#125;<br>    siz[p]=res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> p=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>ans.<span class="hljs-built_in">push_back</span>(p);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=qdge[p].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> y=edge[p][i];<br>in[y]--;<br><span class="hljs-keyword">if</span>(in[y]==<span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(y);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>()==n)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>    cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; \n&quot;</span>[i==ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No Answer!&quot;</span>&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h3 id="输出树节点之间的路径"><a href="#输出树节点之间的路径" class="headerlink" title="输出树节点之间的路径"></a>输出树节点之间的路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">20</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; tree[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> n,x,y;<br><span class="hljs-type">int</span> flag;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span>(u==y)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;cout&lt;&lt;y&lt;&lt;endl;<br>        flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>st[u]=<span class="hljs-number">1</span>;<br>ans.<span class="hljs-built_in">push_back</span>(u);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:tree[u])&#123;<br><span class="hljs-keyword">if</span>(!st[j]&amp;&amp;j!=fa)&#123;<br><span class="hljs-built_in">dfs</span>(j,u);<br>&#125;<br><span class="hljs-comment">//ans.pop_back();</span><br>&#125;<br>st[u]=<span class="hljs-number">0</span>;<br>ans.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> aa,bb;<br>cin&gt;&gt;aa&gt;&gt;bb;<br>tree[aa].<span class="hljs-built_in">push_back</span>(bb);<br>tree[bb].<span class="hljs-built_in">push_back</span>(aa);<br>&#125;<br><span class="hljs-built_in">dfs</span>(x,<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出树的深度"><a href="#输出树的深度" class="headerlink" title="输出树的深度"></a>输出树的深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> d[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; G[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br><span class="hljs-keyword">if</span>(G[u].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>&amp;&amp;G[u][<span class="hljs-number">0</span>]==fa)&#123;<br>        d[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-type">int</span> mmax=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:G[u])&#123;<br><span class="hljs-keyword">if</span>(i==fa) <span class="hljs-keyword">continue</span>;<br>mmax=<span class="hljs-built_in">max</span>(mmax,<span class="hljs-built_in">dfs</span>(i,u));<br>&#125;<br><span class="hljs-keyword">return</span> d[u]=<span class="hljs-built_in">max</span>(d[u],mmax+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>G[x].<span class="hljs-built_in">push_back</span>(y);<br>G[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//    for(int i=1;i&lt;=5;i++)&#123;</span><br><span class="hljs-comment">//        cout&lt;&lt;d[i]&lt;&lt;endl;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:G[<span class="hljs-number">1</span>])&#123;<br>sum+=d[i];<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="染色法求二分图"><a href="#染色法求二分图" class="headerlink" title="染色法求二分图"></a>染色法求二分图</h3><p><img src="/pic/image-20221117130733540.png" alt="image-20221117130733540"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ff first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ss second</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII; <span class="hljs-comment">//first表示节点编号，second表示该结点染成的颜色</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;  <span class="hljs-string">&quot;无向图，边要存储双倍&quot;</span><br>PII q[N]; <span class="hljs-string">&quot;图中的点不会重复加入队列，所以tt最多到N&quot;</span><br><span class="hljs-type">int</span> hh,tt=<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx; <span class="hljs-comment">//无向无权图</span><br><span class="hljs-type">int</span> clr[N];  <span class="hljs-comment">//记录每个点的染色，0代表未染色，1 2分别代表两种不同的颜色,clr数组兼顾了vis数组的作用，全局变量，默认为0</span><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//a-&gt;b</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=b,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> vv,<span class="hljs-type">int</span> cc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//先初始化，起点vv染色为cc</span><br>    clr[vv]=cc;  <br>    q[++tt]=&#123;vv,cc&#125;;<br>    <br>    <span class="hljs-keyword">while</span> (hh&lt;=tt) &#123; <span class="hljs-comment">//当队列中的点没有可达边或都染过色后，队列一直出队列，为空</span><br>        PII t=q[hh++];<br>        <span class="hljs-type">int</span> v=t.ff,c=t.ss;<br>        <span class="hljs-comment">//获取当前节点的编号v和颜色c，开始对它相邻的顶点染色</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=h[v];~i;i=ne[i]) &#123; <span class="hljs-string">&quot;~i等价于i!=-1，-1的二进制补码全1，只有-1取反是全0，此时停止，其他情况下~i都不是0&quot;</span><br>            <span class="hljs-type">int</span> j=e[i];   <span class="hljs-string">&quot;v-&gt;j的边      不同于!i，所有的非零数!i都是0 &quot;</span>                            <br>            <span class="hljs-keyword">if</span> (!clr[j])  clr[j]=<span class="hljs-number">3</span>-c,q[++tt]=&#123;j,clr[j]&#125;; <span class="hljs-comment">//没有染色的情况</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clr[j]==c)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//存在奇数环，矛盾，染色失败</span><br>            <span class="hljs-comment">//还有一种情况，已经染色且clr[j]==3-c，说明存在偶数环，不用染色了，可以跳过，处理其它相邻的点。</span><br>        &#125;   <span class="hljs-comment">//从顶点v出发有很多出边，除了构成回路外，还有其它的点j</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-string">&quot;因队列为空而退出，说明一个连通图中全部染色完成。&quot;</span><br>                  <span class="hljs-string">&quot;因为我们不知道一个连通图中有多少个顶点，所以必须等队列为空退出才行，中途退出则说明染色失败&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">add</span>(a,b),<span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-comment">//判断是否是二分图</span><br>    <span class="hljs-type">bool</span> tag;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<span class="hljs-comment">//防止出现一个图不是连通图的情况，确保每个点都可以染色,结点从1开始编号</span><br>        <span class="hljs-keyword">if</span> (!clr[i]) &#123;<span class="hljs-comment">//每一次bfs就是给一个连通图染色，每一个连通图都从1号颜色开始染色</span><br>            tag=<span class="hljs-built_in">bfs</span>(i,<span class="hljs-number">1</span>); <span class="hljs-comment">//染色，并返回是否染色成功;起点i染色为颜色1</span><br>            <span class="hljs-keyword">if</span> (tag==<span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//染色失败就退出</span><br>        &#125;<br>    &#125;<br>    tag==<span class="hljs-literal">true</span>?<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>):<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//bfs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-type">int</span> clr[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=b,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> c)</span><span class="hljs-comment">//欲将结点为v的顶点染色为c</span></span><br><span class="hljs-function"></span>&#123;            <span class="hljs-string">&quot;从上到下染色，然后回溯返回是否染色成功&quot;</span><br>    <span class="hljs-keyword">if</span> (clr[v]==c) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//偶数环，该路径染色结束，成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clr[v]==<span class="hljs-number">3</span>-c)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//奇数环，该路径染色结束，失败</span><br>    <span class="hljs-keyword">else</span> &#123;                           <span class="hljs-comment">//该点没染色的情况</span><br>        clr[v]=c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=h[v];~i;i=ne[i]) &#123;  <span class="hljs-comment">//给下一层的每个点都进行染色</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(e[i],<span class="hljs-number">3</span>-c)==<span class="hljs-literal">false</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//如果中途发现染色失败就返回</span><br>        &#125;      <span class="hljs-string">&quot;调用函数的同时使用返回值&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//染色成功</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">add</span>(a,b),<span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-type">bool</span> tag;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (!clr[i]) &#123;<br>            tag=<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (tag==<span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    tag==<span class="hljs-literal">true</span>?<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>):<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//dfs</span><br></code></pre></td></tr></table></figure><h2 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(int i = (a); i &lt;= (b); i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,a,b) for(int i = (a); i &gt;= (b); i--)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SZ(x) ((int)(x).size())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<br><span class="hljs-comment">//以下是tarjan部分</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> v,nxt;<br>&#125;edge[<span class="hljs-number">3</span>*N];<br><span class="hljs-type">int</span> head[N],tot;<br><span class="hljs-type">int</span> low[N],dfn[N],Stack[N],belong[N]; <span class="hljs-comment">//belong[x]表示x所属的强连通分量的编号</span><br><span class="hljs-type">int</span> idx,top;<br><span class="hljs-type">int</span> scc;  <span class="hljs-comment">//scc表示强连通分量的个数</span><br><span class="hljs-type">bool</span> instack[N];<br><span class="hljs-type">int</span> num[N];  <span class="hljs-comment">//num[x]表示第x个强连通分量内所包含的点的个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    edge[tot].v = v;<br>    edge[tot].nxt = head[u];<br>    head[u] = tot++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> v;<br>    low[u] = dfn[u] = ++idx;<br>    Stack[top++] = u;<br>    instack[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = edge[i].nxt) &#123;<br>        <span class="hljs-type">int</span> v = edge[i].v;<br>        <span class="hljs-keyword">if</span>(!dfn[v]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(v);<br>            <span class="hljs-keyword">if</span>(low[u]&gt;low[v]) low[u] = low[v];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(instack[v]&amp;&amp;low[u]&gt;dfn[v]) low[u] = dfn[v];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(low[u]==dfn[u]) &#123;<br>        scc++;<br>        <span class="hljs-keyword">do</span> &#123;<br>            v = Stack[--top];<br>            instack[v] = <span class="hljs-number">0</span>;<br>            belong[v] = scc;<br>            num[scc]++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(v!=u);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dfn));<br>    <span class="hljs-built_in">memset</span>(instack,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(instack));<br>    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(num));<br>    idx = scc = top = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>        <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><br><span class="hljs-comment">//以下是拓扑部分</span><br>pii road[<span class="hljs-number">3</span>*N];<br>vector&lt;<span class="hljs-type">int</span>&gt;nxt[N];<br><span class="hljs-type">int</span> deep[N],deg[N];  <span class="hljs-comment">//deep数组为了满足这个题的要求</span><br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(x);<br>    vis[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nxt[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> v = nxt[u][i];<br>            deep[v] = <span class="hljs-built_in">max</span>(deep[v],deep[u]+num[v]);<br>            deg[v]--;<br>            <span class="hljs-keyword">if</span>(deg[v]==<span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>                vis[v]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;a.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m) &#123;<br>        <span class="hljs-built_in">init</span>();         <span class="hljs-comment">//tarjan部分初始化</span><br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>            <span class="hljs-type">int</span> u,v;<br>            cin&gt;&gt;u&gt;&gt;v;<br>            road[i].first = u;<br>            road[i].second = v;<br>            <span class="hljs-built_in">addedge</span>(u,v);<br>        &#125;<br>        <span class="hljs-built_in">solve</span>(n);<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));         <span class="hljs-comment">//拓扑部分的初始化</span><br>        <span class="hljs-built_in">memset</span>(deg,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(deg));<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc) nxt[i].<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) &#123;                     <span class="hljs-comment">//缩点重构图 </span><br>            <span class="hljs-type">int</span> u = road[i].first;<br>            <span class="hljs-type">int</span> v = road[i].second;<br>            <span class="hljs-type">int</span> uu = belong[u];<br>            <span class="hljs-type">int</span> vv = belong[v];<br>            <span class="hljs-keyword">if</span>(uu!=vv) &#123;<br>                nxt[uu].<span class="hljs-built_in">pb</span>(vv);<br>                deg[vv]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc) deep[i] = num[i];   <br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc)                      <br>            <span class="hljs-keyword">if</span>(!deg[i]&amp;&amp;!vis[i]) <span class="hljs-built_in">topo</span>(i);<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc)<br>            ans = <span class="hljs-built_in">max</span>(ans,deep[i]);<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tarjan求lca"><a href="#tarjan求lca" class="headerlink" title="tarjan求lca"></a>tarjan求lca</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br>vector&lt;node&gt;to[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[u]=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:g[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x==fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!vis[x])<br>        &#123;<br>            <span class="hljs-built_in">Tarjan</span>(x,u);<br>            f[x]=u;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [x,y,z]:to[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(vis[x]==<span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-keyword">if</span>(t==u) <span class="hljs-comment">// u是x的lca</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(z==<span class="hljs-number">1</span>)<br>                &#123;<br>                    ans[y]=<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> ans[y]=<span class="hljs-number">2</span>;<br>            &#125;<span class="hljs-keyword">else</span> ans[y]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    vis[u]=<span class="hljs-number">2</span>;<span class="hljs-comment">//不划分成三个状态也行</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)<br>    f[i]=i;<br>    <span class="hljs-type">int</span> root=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">-1</span>)<br>        &#123;<br>            root=a;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            g[a].<span class="hljs-built_in">push_back</span>(b);<br>            g[b].<span class="hljs-built_in">push_back</span>(a);<br>        &#125;<br>    &#125;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        to[a].<span class="hljs-built_in">push_back</span>(&#123;b,i,<span class="hljs-number">1</span>&#125;);<br>        to[b].<span class="hljs-built_in">push_back</span>(&#123;a,i,<span class="hljs-number">2</span>&#125;);<br>    &#125;<br>    <br>    <span class="hljs-built_in">Tarjan</span>(root,<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cout&lt;&lt;ans[i]&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求最短路径"><a href="#求最短路径" class="headerlink" title="求最短路径"></a>求最短路径</h2><h3 id="djisktra求最短路"><a href="#djisktra求最短路" class="headerlink" title="djisktra求最短路"></a>djisktra求最短路</h3><p>注意djisktra算法中不能出现负值的权边</p><p>朴素版本</p><p>注意g数组存储边的长度</p><p>dist数组存储到初始点的距离</p><p>st判断最短路是否已经确定，也就是避免重复</p><p>然后需要注意点的下标要从1开始这样方便直接表示点和边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>另外一种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f</span>;<br><span class="hljs-type">int</span> g[<span class="hljs-number">520</span>][<span class="hljs-number">520</span>];<br><span class="hljs-type">int</span> st[<span class="hljs-number">520</span>];<br><span class="hljs-type">int</span> dist[<span class="hljs-number">520</span>];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IO;<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br><span class="hljs-built_in">memset</span>(g,INF,<span class="hljs-built_in">sizeof</span>(g));<br>dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;<br>g[x][y]=<span class="hljs-built_in">min</span>(g[x][y],k);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br><span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))&#123;<br>t=j;<br>&#125;<br>&#125;<br>st[t]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>dist[i]=<span class="hljs-built_in">min</span>(dist[i],dist[t]+g[t][i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>)&#123;<br>cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>dij+路径计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//It is made by HolseLee on 8th Aug 2018</span><br><span class="hljs-comment">//Dijkstra</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e5</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m,sta,ed,dis[N],p[N],head[N],size;<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> to,val,next;<br>&#125;edge[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> dis[a]&gt;dis[b];<br>    &#125;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,Cmp&gt; t;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)flag=<span class="hljs-literal">true</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;num=num*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">return</span> flag?-num:num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[++size].to=y;<br>    edge[size].val=z;<br>    edge[size].next=head[x];<br>    head[x]=size;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-literal">false</span>));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    t.<span class="hljs-built_in">push</span>(sta);<br>    dis[sta]=<span class="hljs-number">0</span>;p[sta]=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x,y,z;<br>    <span class="hljs-keyword">while</span>(!t.<span class="hljs-built_in">empty</span>())&#123;<br>        x=t.<span class="hljs-built_in">top</span>();t.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(vis[x])<span class="hljs-keyword">continue</span>;<br>        vis[x]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i!=<span class="hljs-number">-1</span>;i=edge[i].next)&#123;<br>            y=edge[i].to;<br>            <span class="hljs-keyword">if</span>(dis[y]==dis[x]+edge[i].val)<br>                p[y]=(p[x]+p[y])%mod;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis[y]&gt;dis[x]+edge[i].val)&#123;<br>                dis[y]=dis[x]+edge[i].val;<br>                p[y]=p[x];<br>                t.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();<br>    sta=<span class="hljs-built_in">read</span>();ed=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>    <span class="hljs-type">int</span> x,y,z;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>        x=<span class="hljs-built_in">read</span>();y=<span class="hljs-built_in">read</span>();z=<span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">add</span>(x,y,z);<span class="hljs-built_in">add</span>(y,x,z);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,dis[ed],p[ed]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h3><p>把dist放到一个堆里面就可以省去for循环查找了</p><p>使o(n)变成了(logn)  </p><p><img src="/pic/image-20220727152930664.png" alt="image-20220727152930664"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5e4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f</span>;<br><span class="hljs-type">int</span> n,m,idx,e[N],h[N],ne[N],w[N],st[N],dist[N];<br><span class="hljs-comment">//h存储头节点</span><br><span class="hljs-comment">//e存储点的值 </span><br><span class="hljs-comment">//ne存储下一个节点的位置</span><br><span class="hljs-comment">//w存储边的权值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> c)</span></span>&#123;<br>w[idx]=c;<br>e[idx]=y;<br>ne[idx]=h[x];<br>h[x]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;heap;<br>heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//fi length,se num</span><br><span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-type">int</span> vec=heap.<span class="hljs-built_in">top</span>().se;<br><span class="hljs-type">int</span> p=heap.<span class="hljs-built_in">top</span>().fi;<br><span class="hljs-comment">//cout&lt;&lt;&quot;s&quot;&lt;&lt;vec&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;endl;</span><br>heap.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(st[vec])&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>st[vec]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[vec];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-keyword">if</span>(dist[j]&gt;p+w[i])&#123;<br>dist[j]=<span class="hljs-built_in">min</span>(dist[j],p+w[i]);<br>heap.<span class="hljs-built_in">push</span>(&#123;dist[j],j&#125;);<br>&#125;<br><br>        &#125;<br>&#125;<br><span class="hljs-comment">//for(int i=h[1];i!=-1;i=ne[i])&#123;</span><br><span class="hljs-comment">//cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="hljs-comment">//cout&lt;&lt;dist[i]&lt;&lt;&quot; \n&quot;[i==n];</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">if</span>(dist[n]&gt;=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>)&#123;<br>cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[n]&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IO;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br><span class="hljs-built_in">memset</span>(w,INF,<span class="hljs-built_in">sizeof</span>(w));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br><span class="hljs-built_in">add</span>(x,y,z);<br>&#125;<br><span class="hljs-comment">//dist[1]=0;</span><br><span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SPFA-bellman-ford-算法"><a href="#SPFA-bellman-ford-算法" class="headerlink" title="SPFA(bellman_ford)算法"></a>SPFA(bellman_ford)算法</h3><p>朴素版对于每一个点的每一条边都进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 边，a表示出点，b表示入点，w表示边的权重</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是另外一种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> w;<br>&#125; e[M];<span class="hljs-comment">//把每个边保存下来即可</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> back[N];<span class="hljs-comment">//备份数组防止串联</span><br><span class="hljs-type">int</span> n, m, k;<span class="hljs-comment">//k代表最短路径最多包涵k条边</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-comment">//k次循环</span><br>        <span class="hljs-built_in">memcpy</span>(back, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-comment">//遍历所有边</span><br>            <span class="hljs-type">int</span> a = e[j].a, b = e[j].b, w = e[j].w;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], back[a] + w);<br>            <span class="hljs-comment">//使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来</span><br>            <span class="hljs-comment">//避免连续更新</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);<br>        e[i] = &#123;a, b, w&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用队列优化"><a href="#利用队列优化" class="headerlink" title="利用队列优化"></a><strong>利用队列优化</strong></h3><p><img src="/pic/image-20220727185329057.png" alt="image-20220727185329057"></p><p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p><p> st数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。<br>即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。</p><p>用自己的话说就是先把把经过的点放入队列中，然后遍历可以到达的结点，最后将dist较小的插入并且st[j]表示为true的状态</p><h3 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是"></a><strong>值得注意的是</strong></h3><p>1) st数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。<br>即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。<br>2) SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</p><p>1] Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。<br>2] Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</p><p>3) ⭐️Bellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f/2;而spfa算法写的是dist[n]==0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p><p>4) ⭐️ Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</p><p>5) ⭐️由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 O(nm)O(nm) ，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)</p><p>6) ⭐️求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。</p><p>出队的时候就可以将st[j]表示为false的状态了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5e4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f</span>;<br><span class="hljs-type">int</span> n,m,idx,e[N],h[N],ne[N],w[N],st[N],dist[N];<br><span class="hljs-comment">//h存储头节点</span><br><span class="hljs-comment">//e存储点的值</span><br><span class="hljs-comment">//ne存储下一个节点的位置</span><br><span class="hljs-comment">//w存储边的权值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> c)</span></span>&#123;<br>w[idx]=c;<br>e[idx]=y;<br>ne[idx]=h[x];<br>h[x]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br> st[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> tmp=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>st[tmp]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[tmp];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-keyword">if</span>(dist[j]&gt;dist[tmp]+w[i])&#123;<br>dist[j]=dist[tmp]+w[i];<br><span class="hljs-keyword">if</span>(!st[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j);<br>st[j]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dist[n]==INF)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IO;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br><span class="hljs-built_in">memset</span>(w,INF,<span class="hljs-built_in">sizeof</span>(w));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br><span class="hljs-built_in">add</span>(x,y,z);<br>&#125;<br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="FLOYD"><a href="#FLOYD" class="headerlink" title="FLOYD"></a>FLOYD</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, M = <span class="hljs-number">2e+10</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> n, m, k, x, y, z;<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br>    <span class="hljs-keyword">while</span>(m--) &#123;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        d[x][y] = <span class="hljs-built_in">min</span>(d[x][y], z);<br>        <span class="hljs-comment">//注意保存最小的边</span><br>    &#125;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--) &#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(d[x][y] &gt; INF/<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-comment">//由于有负权边存在所以约大过INF/2也很合理</span><br>        <span class="hljs-keyword">else</span> cout &lt;&lt; d[x][y] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="PRIM"><a href="#PRIM" class="headerlink" title="PRIM"></a>PRIM</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp">朴素版prim算法 —— 模板题 AcWing <span class="hljs-number">858.</span> Prim算法求最小生成树<br>时间复杂度是 <span class="hljs-built_in">O</span>(n2+m)<span class="hljs-built_in">O</span>(n2+m), nn 表示点数，mm 表示边数<br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br>Kruskal算法 —— 模板题 AcWing <span class="hljs-number">859.</span> Kruskal算法求最小生成树<br>时间复杂度是 <span class="hljs-built_in">O</span>(mlogm), n 表示点数，m 表示边数<br><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dt[N];<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(dt,<span class="hljs-number">0x3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(dt));<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>dt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br><span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dt[j]&lt;dt[t]))&#123;<br>t=j;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(dt[t]&gt;=<span class="hljs-number">1e9</span>+<span class="hljs-number">20</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><br>st[t]=<span class="hljs-number">1</span>;<br>res+=dt[t];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(dt[i]&gt;g[t][i]&amp;&amp;!st[i])&#123;<br>dt[i]=g[t][i];<br>pre[i]=t;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getpath</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;pre[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> a,b,w;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>g[a][b]=g[b][a]=<span class="hljs-built_in">min</span>(g[a][b],w);<br>&#125;<br><span class="hljs-built_in">prim</span>();<br><span class="hljs-comment">//getpath();</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="KRUSKAL"><a href="#KRUSKAL" class="headerlink" title="KRUSKAL"></a>KRUSKAL</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> first fi</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> second se</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span> </span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<br><span class="hljs-type">int</span> x,y,v;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> E&amp; o)&#123;<br><span class="hljs-keyword">return</span> v&lt;o.v;<br>&#125;<br>&#125;edg[N*<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p[a]!=a) p[a]=<span class="hljs-built_in">find</span>(p[a]);<br><span class="hljs-keyword">return</span> p[a];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kru</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> pa=<span class="hljs-built_in">find</span>(edg[i].x);<br><span class="hljs-type">int</span> pb=<span class="hljs-built_in">find</span>(edg[i].y);<br><span class="hljs-comment">//cout&lt;&lt;pa&lt;&lt;&quot; &quot;&lt;&lt;pb&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(pa!=pb)&#123;<span class="hljs-comment">//不在一个集合中 </span><br>res+=edg[i].v;<br>p[pa]=pb;<br><span class="hljs-comment">//merge</span><br>cnt++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> x,y,v;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;<br>edg[i]=&#123;x,y,v&#125;;<br>p[i]=i;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(edg+<span class="hljs-number">1</span>,edg+<span class="hljs-number">1</span>+m);<br><br><span class="hljs-built_in">kru</span>();<br><br><span class="hljs-keyword">if</span>(cnt&gt;=n<span class="hljs-number">-1</span>)&#123;<br>cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/pic/image-20220808231509638.png" alt="image-20220808231509638"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> tarjan </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
