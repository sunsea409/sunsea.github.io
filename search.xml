<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图论</title>
      <link href="/2023/08/11/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2023/08/11/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="邻接表的构造和深广优先遍历"><a href="#邻接表的构造和深广优先遍历" class="headerlink" title="邻接表的构造和深广优先遍历"></a>邻接表的构造和深广优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N],e[N],ne[N],idx,st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx]=b,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    idx=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-comment">//..</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些初始化操作"><a href="#一些初始化操作" class="headerlink" title="一些初始化操作"></a>一些初始化操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>st[u]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//st[]==true则表示st[u]这个点已经被遍历过了</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br> <span class="hljs-type">int</span> j=e[i];<br> <span class="hljs-keyword">if</span>(!st[j])&#123;<br> <span class="hljs-built_in">dfs</span>(j);<br> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="深度优先遍历的模板"><a href="#深度优先遍历的模板" class="headerlink" title="深度优先遍历的模板"></a>深度优先遍历的模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br><span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:e[p])&#123;<br><span class="hljs-keyword">if</span>(it==q)&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-type">int</span> rres=<span class="hljs-built_in">dfs</span>(it,p);<br>res+=rres;<br>&#125;<br>siz[p]=res;<br><span class="hljs-comment">//cout&lt;&lt;res&lt;&lt;&quot;_&quot;&lt;&lt;endl;</span><br><span class="hljs-comment">//在这里就可以直接判断子节点数的一些性质了 </span><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//dfs求子树的子节点数</span><br><br></code></pre></td></tr></table></figure><h3 id="求节点的子树的节点和"><a href="#求节点的子树的节点和" class="headerlink" title="求节点的子树的节点和"></a>求节点的子树的节点和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br><span class="hljs-type">int</span> res=e[p].second;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:e[p])&#123;<br><span class="hljs-keyword">if</span>(it==q)&#123;<br><span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> rres=<span class="hljs-built_in">dfs</span>(it,p);<br>        res+=rres;<br>    &#125;<br>    siz[p]=res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>vector&lt;<span class="hljs-type">int</span>&gt; edge[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> p=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>ans.<span class="hljs-built_in">push_back</span>(p);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=qdge[p].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> y=edge[p][i];<br>in[y]--;<br><span class="hljs-keyword">if</span>(in[y]==<span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(y);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>()==n)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>    cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; \n&quot;</span>[i==ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No Answer!&quot;</span>&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h3 id="输出树节点之间的路径"><a href="#输出树节点之间的路径" class="headerlink" title="输出树节点之间的路径"></a>输出树节点之间的路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">20</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; tree[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> n,x,y;<br><span class="hljs-type">int</span> flag;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span>(u==y)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;cout&lt;&lt;y&lt;&lt;endl;<br>        flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>st[u]=<span class="hljs-number">1</span>;<br>ans.<span class="hljs-built_in">push_back</span>(u);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:tree[u])&#123;<br><span class="hljs-keyword">if</span>(!st[j]&amp;&amp;j!=fa)&#123;<br><span class="hljs-built_in">dfs</span>(j,u);<br>&#125;<br><span class="hljs-comment">//ans.pop_back();</span><br>&#125;<br>st[u]=<span class="hljs-number">0</span>;<br>ans.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> aa,bb;<br>cin&gt;&gt;aa&gt;&gt;bb;<br>tree[aa].<span class="hljs-built_in">push_back</span>(bb);<br>tree[bb].<span class="hljs-built_in">push_back</span>(aa);<br>&#125;<br><span class="hljs-built_in">dfs</span>(x,<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出树的深度"><a href="#输出树的深度" class="headerlink" title="输出树的深度"></a>输出树的深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> d[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; G[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br><span class="hljs-keyword">if</span>(G[u].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>&amp;&amp;G[u][<span class="hljs-number">0</span>]==fa)&#123;<br>        d[u]=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-type">int</span> mmax=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:G[u])&#123;<br><span class="hljs-keyword">if</span>(i==fa) <span class="hljs-keyword">continue</span>;<br>mmax=<span class="hljs-built_in">max</span>(mmax,<span class="hljs-built_in">dfs</span>(i,u));<br>&#125;<br><span class="hljs-keyword">return</span> d[u]=<span class="hljs-built_in">max</span>(d[u],mmax+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>G[x].<span class="hljs-built_in">push_back</span>(y);<br>G[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//    for(int i=1;i&lt;=5;i++)&#123;</span><br><span class="hljs-comment">//        cout&lt;&lt;d[i]&lt;&lt;endl;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:G[<span class="hljs-number">1</span>])&#123;<br>sum+=d[i];<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="染色法求二分图"><a href="#染色法求二分图" class="headerlink" title="染色法求二分图"></a>染色法求二分图</h3><p><img src="/pic/image-20221117130733540.png" alt="image-20221117130733540"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ff first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ss second</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII; <span class="hljs-comment">//first表示节点编号，second表示该结点染成的颜色</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;  <span class="hljs-string">&quot;无向图，边要存储双倍&quot;</span><br>PII q[N]; <span class="hljs-string">&quot;图中的点不会重复加入队列，所以tt最多到N&quot;</span><br><span class="hljs-type">int</span> hh,tt=<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx; <span class="hljs-comment">//无向无权图</span><br><span class="hljs-type">int</span> clr[N];  <span class="hljs-comment">//记录每个点的染色，0代表未染色，1 2分别代表两种不同的颜色,clr数组兼顾了vis数组的作用，全局变量，默认为0</span><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//a-&gt;b</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=b,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> vv,<span class="hljs-type">int</span> cc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//先初始化，起点vv染色为cc</span><br>    clr[vv]=cc;  <br>    q[++tt]=&#123;vv,cc&#125;;<br>    <br>    <span class="hljs-keyword">while</span> (hh&lt;=tt) &#123; <span class="hljs-comment">//当队列中的点没有可达边或都染过色后，队列一直出队列，为空</span><br>        PII t=q[hh++];<br>        <span class="hljs-type">int</span> v=t.ff,c=t.ss;<br>        <span class="hljs-comment">//获取当前节点的编号v和颜色c，开始对它相邻的顶点染色</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=h[v];~i;i=ne[i]) &#123; <span class="hljs-string">&quot;~i等价于i!=-1，-1的二进制补码全1，只有-1取反是全0，此时停止，其他情况下~i都不是0&quot;</span><br>            <span class="hljs-type">int</span> j=e[i];   <span class="hljs-string">&quot;v-&gt;j的边      不同于!i，所有的非零数!i都是0 &quot;</span>                            <br>            <span class="hljs-keyword">if</span> (!clr[j])  clr[j]=<span class="hljs-number">3</span>-c,q[++tt]=&#123;j,clr[j]&#125;; <span class="hljs-comment">//没有染色的情况</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clr[j]==c)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//存在奇数环，矛盾，染色失败</span><br>            <span class="hljs-comment">//还有一种情况，已经染色且clr[j]==3-c，说明存在偶数环，不用染色了，可以跳过，处理其它相邻的点。</span><br>        &#125;   <span class="hljs-comment">//从顶点v出发有很多出边，除了构成回路外，还有其它的点j</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-string">&quot;因队列为空而退出，说明一个连通图中全部染色完成。&quot;</span><br>                  <span class="hljs-string">&quot;因为我们不知道一个连通图中有多少个顶点，所以必须等队列为空退出才行，中途退出则说明染色失败&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">add</span>(a,b),<span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-comment">//判断是否是二分图</span><br>    <span class="hljs-type">bool</span> tag;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<span class="hljs-comment">//防止出现一个图不是连通图的情况，确保每个点都可以染色,结点从1开始编号</span><br>        <span class="hljs-keyword">if</span> (!clr[i]) &#123;<span class="hljs-comment">//每一次bfs就是给一个连通图染色，每一个连通图都从1号颜色开始染色</span><br>            tag=<span class="hljs-built_in">bfs</span>(i,<span class="hljs-number">1</span>); <span class="hljs-comment">//染色，并返回是否染色成功;起点i染色为颜色1</span><br>            <span class="hljs-keyword">if</span> (tag==<span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//染色失败就退出</span><br>        &#125;<br>    &#125;<br>    tag==<span class="hljs-literal">true</span>?<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>):<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//bfs</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-type">int</span> clr[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=b,ne[idx]=h[a],h[a]=idx++;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> c)</span><span class="hljs-comment">//欲将结点为v的顶点染色为c</span></span><br><span class="hljs-function"></span>&#123;            <span class="hljs-string">&quot;从上到下染色，然后回溯返回是否染色成功&quot;</span><br>    <span class="hljs-keyword">if</span> (clr[v]==c) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//偶数环，该路径染色结束，成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clr[v]==<span class="hljs-number">3</span>-c)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//奇数环，该路径染色结束，失败</span><br>    <span class="hljs-keyword">else</span> &#123;                           <span class="hljs-comment">//该点没染色的情况</span><br>        clr[v]=c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=h[v];~i;i=ne[i]) &#123;  <span class="hljs-comment">//给下一层的每个点都进行染色</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(e[i],<span class="hljs-number">3</span>-c)==<span class="hljs-literal">false</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//如果中途发现染色失败就返回</span><br>        &#125;      <span class="hljs-string">&quot;调用函数的同时使用返回值&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//染色成功</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-built_in">add</span>(a,b),<span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-type">bool</span> tag;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>        <span class="hljs-keyword">if</span> (!clr[i]) &#123;<br>            tag=<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (tag==<span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    tag==<span class="hljs-literal">true</span>?<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>):<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//dfs</span><br></code></pre></td></tr></table></figure><h2 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(int i = (a); i &lt;= (b); i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,a,b) for(int i = (a); i &gt;= (b); i--)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SZ(x) ((int)(x).size())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">100</span>;<br><span class="hljs-comment">//以下是tarjan部分</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> v,nxt;<br>&#125;edge[<span class="hljs-number">3</span>*N];<br><span class="hljs-type">int</span> head[N],tot;<br><span class="hljs-type">int</span> low[N],dfn[N],Stack[N],belong[N]; <span class="hljs-comment">//belong[x]表示x所属的强连通分量的编号</span><br><span class="hljs-type">int</span> idx,top;<br><span class="hljs-type">int</span> scc;  <span class="hljs-comment">//scc表示强连通分量的个数</span><br><span class="hljs-type">bool</span> instack[N];<br><span class="hljs-type">int</span> num[N];  <span class="hljs-comment">//num[x]表示第x个强连通分量内所包含的点的个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    edge[tot].v = v;<br>    edge[tot].nxt = head[u];<br>    head[u] = tot++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> v;<br>    low[u] = dfn[u] = ++idx;<br>    Stack[top++] = u;<br>    instack[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = edge[i].nxt) &#123;<br>        <span class="hljs-type">int</span> v = edge[i].v;<br>        <span class="hljs-keyword">if</span>(!dfn[v]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(v);<br>            <span class="hljs-keyword">if</span>(low[u]&gt;low[v]) low[u] = low[v];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(instack[v]&amp;&amp;low[u]&gt;dfn[v]) low[u] = dfn[v];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(low[u]==dfn[u]) &#123;<br>        scc++;<br>        <span class="hljs-keyword">do</span> &#123;<br>            v = Stack[--top];<br>            instack[v] = <span class="hljs-number">0</span>;<br>            belong[v] = scc;<br>            num[scc]++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(v!=u);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dfn));<br>    <span class="hljs-built_in">memset</span>(instack,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(instack));<br>    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(num));<br>    idx = scc = top = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>        <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><br><span class="hljs-comment">//以下是拓扑部分</span><br>pii road[<span class="hljs-number">3</span>*N];<br>vector&lt;<span class="hljs-type">int</span>&gt;nxt[N];<br><span class="hljs-type">int</span> deep[N],deg[N];  <span class="hljs-comment">//deep数组为了满足这个题的要求</span><br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(x);<br>    vis[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nxt[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> v = nxt[u][i];<br>            deep[v] = <span class="hljs-built_in">max</span>(deep[v],deep[u]+num[v]);<br>            deg[v]--;<br>            <span class="hljs-keyword">if</span>(deg[v]==<span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>                vis[v]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;a.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m) &#123;<br>        <span class="hljs-built_in">init</span>();         <span class="hljs-comment">//tarjan部分初始化</span><br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>            <span class="hljs-type">int</span> u,v;<br>            cin&gt;&gt;u&gt;&gt;v;<br>            road[i].first = u;<br>            road[i].second = v;<br>            <span class="hljs-built_in">addedge</span>(u,v);<br>        &#125;<br>        <span class="hljs-built_in">solve</span>(n);<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));         <span class="hljs-comment">//拓扑部分的初始化</span><br>        <span class="hljs-built_in">memset</span>(deg,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(deg));<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc) nxt[i].<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) &#123;                     <span class="hljs-comment">//缩点重构图 </span><br>            <span class="hljs-type">int</span> u = road[i].first;<br>            <span class="hljs-type">int</span> v = road[i].second;<br>            <span class="hljs-type">int</span> uu = belong[u];<br>            <span class="hljs-type">int</span> vv = belong[v];<br>            <span class="hljs-keyword">if</span>(uu!=vv) &#123;<br>                nxt[uu].<span class="hljs-built_in">pb</span>(vv);<br>                deg[vv]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc) deep[i] = num[i];   <br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc)                      <br>            <span class="hljs-keyword">if</span>(!deg[i]&amp;&amp;!vis[i]) <span class="hljs-built_in">topo</span>(i);<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, scc)<br>            ans = <span class="hljs-built_in">max</span>(ans,deep[i]);<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tarjan求lca"><a href="#tarjan求lca" class="headerlink" title="tarjan求lca"></a>tarjan求lca</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br>vector&lt;node&gt;to[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[u]=<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:g[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x==fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!vis[x])<br>        &#123;<br>            <span class="hljs-built_in">Tarjan</span>(x,u);<br>            f[x]=u;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [x,y,z]:to[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(vis[x]==<span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-keyword">if</span>(t==u) <span class="hljs-comment">// u是x的lca</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(z==<span class="hljs-number">1</span>)<br>                &#123;<br>                    ans[y]=<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> ans[y]=<span class="hljs-number">2</span>;<br>            &#125;<span class="hljs-keyword">else</span> ans[y]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    vis[u]=<span class="hljs-number">2</span>;<span class="hljs-comment">//不划分成三个状态也行</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)<br>    f[i]=i;<br>    <span class="hljs-type">int</span> root=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">-1</span>)<br>        &#123;<br>            root=a;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            g[a].<span class="hljs-built_in">push_back</span>(b);<br>            g[b].<span class="hljs-built_in">push_back</span>(a);<br>        &#125;<br>    &#125;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        to[a].<span class="hljs-built_in">push_back</span>(&#123;b,i,<span class="hljs-number">1</span>&#125;);<br>        to[b].<span class="hljs-built_in">push_back</span>(&#123;a,i,<span class="hljs-number">2</span>&#125;);<br>    &#125;<br>    <br>    <span class="hljs-built_in">Tarjan</span>(root,<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cout&lt;&lt;ans[i]&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求最短路径"><a href="#求最短路径" class="headerlink" title="求最短路径"></a>求最短路径</h2><h3 id="djisktra求最短路"><a href="#djisktra求最短路" class="headerlink" title="djisktra求最短路"></a>djisktra求最短路</h3><p>注意djisktra算法中不能出现负值的权边</p><p>朴素版本</p><p>注意g数组存储边的长度</p><p>dist数组存储到初始点的距离</p><p>st判断最短路是否已经确定，也就是避免重复</p><p>然后需要注意点的下标要从1开始这样方便直接表示点和边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>另外一种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f</span>;<br><span class="hljs-type">int</span> g[<span class="hljs-number">520</span>][<span class="hljs-number">520</span>];<br><span class="hljs-type">int</span> st[<span class="hljs-number">520</span>];<br><span class="hljs-type">int</span> dist[<span class="hljs-number">520</span>];<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IO;<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br><span class="hljs-built_in">memset</span>(g,INF,<span class="hljs-built_in">sizeof</span>(g));<br>dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;<br>g[x][y]=<span class="hljs-built_in">min</span>(g[x][y],k);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br><span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))&#123;<br>t=j;<br>&#125;<br>&#125;<br>st[t]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>dist[i]=<span class="hljs-built_in">min</span>(dist[i],dist[t]+g[t][i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>)&#123;<br>cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>dij+路径计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//It is made by HolseLee on 8th Aug 2018</span><br><span class="hljs-comment">//Dijkstra</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e5</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m,sta,ed,dis[N],p[N],head[N],size;<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> to,val,next;<br>&#125;edge[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> dis[a]&gt;dis[b];<br>    &#125;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,Cmp&gt; t;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)flag=<span class="hljs-literal">true</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;num=num*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">return</span> flag?-num:num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[++size].to=y;<br>    edge[size].val=z;<br>    edge[size].next=head[x];<br>    head[x]=size;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-literal">false</span>));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    t.<span class="hljs-built_in">push</span>(sta);<br>    dis[sta]=<span class="hljs-number">0</span>;p[sta]=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x,y,z;<br>    <span class="hljs-keyword">while</span>(!t.<span class="hljs-built_in">empty</span>())&#123;<br>        x=t.<span class="hljs-built_in">top</span>();t.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(vis[x])<span class="hljs-keyword">continue</span>;<br>        vis[x]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i!=<span class="hljs-number">-1</span>;i=edge[i].next)&#123;<br>            y=edge[i].to;<br>            <span class="hljs-keyword">if</span>(dis[y]==dis[x]+edge[i].val)<br>                p[y]=(p[x]+p[y])%mod;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis[y]&gt;dis[x]+edge[i].val)&#123;<br>                dis[y]=dis[x]+edge[i].val;<br>                p[y]=p[x];<br>                t.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();<br>    sta=<span class="hljs-built_in">read</span>();ed=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br>    <span class="hljs-type">int</span> x,y,z;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>        x=<span class="hljs-built_in">read</span>();y=<span class="hljs-built_in">read</span>();z=<span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">add</span>(x,y,z);<span class="hljs-built_in">add</span>(y,x,z);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,dis[ed],p[ed]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h3><p>把dist放到一个堆里面就可以省去for循环查找了</p><p>使o(n)变成了(logn)  </p><p><img src="/pic/image-20220727152930664.png" alt="image-20220727152930664"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5e4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f</span>;<br><span class="hljs-type">int</span> n,m,idx,e[N],h[N],ne[N],w[N],st[N],dist[N];<br><span class="hljs-comment">//h存储头节点</span><br><span class="hljs-comment">//e存储点的值 </span><br><span class="hljs-comment">//ne存储下一个节点的位置</span><br><span class="hljs-comment">//w存储边的权值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> c)</span></span>&#123;<br>w[idx]=c;<br>e[idx]=y;<br>ne[idx]=h[x];<br>h[x]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;heap;<br>heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//fi length,se num</span><br><span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-type">int</span> vec=heap.<span class="hljs-built_in">top</span>().se;<br><span class="hljs-type">int</span> p=heap.<span class="hljs-built_in">top</span>().fi;<br><span class="hljs-comment">//cout&lt;&lt;&quot;s&quot;&lt;&lt;vec&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;endl;</span><br>heap.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(st[vec])&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>st[vec]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[vec];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-keyword">if</span>(dist[j]&gt;p+w[i])&#123;<br>dist[j]=<span class="hljs-built_in">min</span>(dist[j],p+w[i]);<br>heap.<span class="hljs-built_in">push</span>(&#123;dist[j],j&#125;);<br>&#125;<br><br>        &#125;<br>&#125;<br><span class="hljs-comment">//for(int i=h[1];i!=-1;i=ne[i])&#123;</span><br><span class="hljs-comment">//cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="hljs-comment">//cout&lt;&lt;dist[i]&lt;&lt;&quot; \n&quot;[i==n];</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">if</span>(dist[n]&gt;=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>)&#123;<br>cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[n]&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IO;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br><span class="hljs-built_in">memset</span>(w,INF,<span class="hljs-built_in">sizeof</span>(w));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br><span class="hljs-built_in">add</span>(x,y,z);<br>&#125;<br><span class="hljs-comment">//dist[1]=0;</span><br><span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SPFA-bellman-ford-算法"><a href="#SPFA-bellman-ford-算法" class="headerlink" title="SPFA(bellman_ford)算法"></a>SPFA(bellman_ford)算法</h3><p>朴素版对于每一个点的每一条边都进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 边，a表示出点，b表示入点，w表示边的权重</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是另外一种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> w;<br>&#125; e[M];<span class="hljs-comment">//把每个边保存下来即可</span><br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> back[N];<span class="hljs-comment">//备份数组防止串联</span><br><span class="hljs-type">int</span> n, m, k;<span class="hljs-comment">//k代表最短路径最多包涵k条边</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-comment">//k次循环</span><br>        <span class="hljs-built_in">memcpy</span>(back, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-comment">//遍历所有边</span><br>            <span class="hljs-type">int</span> a = e[j].a, b = e[j].b, w = e[j].w;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], back[a] + w);<br>            <span class="hljs-comment">//使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来</span><br>            <span class="hljs-comment">//避免连续更新</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);<br>        e[i] = &#123;a, b, w&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; res;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用队列优化"><a href="#利用队列优化" class="headerlink" title="利用队列优化"></a><strong>利用队列优化</strong></h3><p><img src="/pic/image-20220727185329057.png" alt="image-20220727185329057"></p><p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p><p> st数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。<br>即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。</p><p>用自己的话说就是先把把经过的点放入队列中，然后遍历可以到达的结点，最后将dist较小的插入并且st[j]表示为true的状态</p><h3 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是"></a><strong>值得注意的是</strong></h3><p>1) st数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。<br>即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。<br>2) SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</p><p>1] Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。<br>2] Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</p><p>3) ⭐️Bellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f/2;而spfa算法写的是dist[n]==0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p><p>4) ⭐️ Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</p><p>5) ⭐️由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 O(nm)O(nm) ，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)</p><p>6) ⭐️求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。</p><p>出队的时候就可以将st[j]表示为false的状态了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5e4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f</span>;<br><span class="hljs-type">int</span> n,m,idx,e[N],h[N],ne[N],w[N],st[N],dist[N];<br><span class="hljs-comment">//h存储头节点</span><br><span class="hljs-comment">//e存储点的值</span><br><span class="hljs-comment">//ne存储下一个节点的位置</span><br><span class="hljs-comment">//w存储边的权值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> c)</span></span>&#123;<br>w[idx]=c;<br>e[idx]=y;<br>ne[idx]=h[x];<br>h[x]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br> st[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> tmp=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>st[tmp]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[tmp];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-keyword">if</span>(dist[j]&gt;dist[tmp]+w[i])&#123;<br>dist[j]=dist[tmp]+w[i];<br><span class="hljs-keyword">if</span>(!st[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j);<br>st[j]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dist[n]==INF)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IO;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(h));<br><span class="hljs-built_in">memset</span>(w,INF,<span class="hljs-built_in">sizeof</span>(w));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(st));<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br><span class="hljs-built_in">add</span>(x,y,z);<br>&#125;<br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="FLOYD"><a href="#FLOYD" class="headerlink" title="FLOYD"></a>FLOYD</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, M = <span class="hljs-number">2e+10</span>, INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> n, m, k, x, y, z;<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br>    <span class="hljs-keyword">while</span>(m--) &#123;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        d[x][y] = <span class="hljs-built_in">min</span>(d[x][y], z);<br>        <span class="hljs-comment">//注意保存最小的边</span><br>    &#125;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--) &#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(d[x][y] &gt; INF/<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-comment">//由于有负权边存在所以约大过INF/2也很合理</span><br>        <span class="hljs-keyword">else</span> cout &lt;&lt; d[x][y] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="PRIM"><a href="#PRIM" class="headerlink" title="PRIM"></a>PRIM</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp">朴素版prim算法 —— 模板题 AcWing <span class="hljs-number">858.</span> Prim算法求最小生成树<br>时间复杂度是 <span class="hljs-built_in">O</span>(n2+m)<span class="hljs-built_in">O</span>(n2+m), nn 表示点数，mm 表示边数<br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br>Kruskal算法 —— 模板题 AcWing <span class="hljs-number">859.</span> Kruskal算法求最小生成树<br>时间复杂度是 <span class="hljs-built_in">O</span>(mlogm), n 表示点数，m 表示边数<br><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dt[N];<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(dt,<span class="hljs-number">0x3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(dt));<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>dt[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br><span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dt[j]&lt;dt[t]))&#123;<br>t=j;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(dt[t]&gt;=<span class="hljs-number">1e9</span>+<span class="hljs-number">20</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><br>st[t]=<span class="hljs-number">1</span>;<br>res+=dt[t];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(dt[i]&gt;g[t][i]&amp;&amp;!st[i])&#123;<br>dt[i]=g[t][i];<br>pre[i]=t;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getpath</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;pre[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> a,b,w;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>g[a][b]=g[b][a]=<span class="hljs-built_in">min</span>(g[a][b],w);<br>&#125;<br><span class="hljs-built_in">prim</span>();<br><span class="hljs-comment">//getpath();</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="KRUSKAL"><a href="#KRUSKAL" class="headerlink" title="KRUSKAL"></a>KRUSKAL</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> first fi</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> second se</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span> </span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;<br><span class="hljs-type">int</span> x,y,v;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> E&amp; o)&#123;<br><span class="hljs-keyword">return</span> v&lt;o.v;<br>&#125;<br>&#125;edg[N*<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p[a]!=a) p[a]=<span class="hljs-built_in">find</span>(p[a]);<br><span class="hljs-keyword">return</span> p[a];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kru</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> pa=<span class="hljs-built_in">find</span>(edg[i].x);<br><span class="hljs-type">int</span> pb=<span class="hljs-built_in">find</span>(edg[i].y);<br><span class="hljs-comment">//cout&lt;&lt;pa&lt;&lt;&quot; &quot;&lt;&lt;pb&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(pa!=pb)&#123;<span class="hljs-comment">//不在一个集合中 </span><br>res+=edg[i].v;<br>p[pa]=pb;<br><span class="hljs-comment">//merge</span><br>cnt++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> x,y,v;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;<br>edg[i]=&#123;x,y,v&#125;;<br>p[i]=i;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(edg+<span class="hljs-number">1</span>,edg+<span class="hljs-number">1</span>+m);<br><br><span class="hljs-built_in">kru</span>();<br><br><span class="hljs-keyword">if</span>(cnt&gt;=n<span class="hljs-number">-1</span>)&#123;<br>cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/pic/image-20220808231509638.png" alt="image-20220808231509638"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> C++ </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="/2023/08/11/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2023/08/11/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="一-巴什博奕（Bash-Game）："><a href="#一-巴什博奕（Bash-Game）：" class="headerlink" title="一.  巴什博奕（Bash Game）："></a>一.  巴什博奕（Bash Game）：</h2><p>  A和B一块报数，每人每次报最少1个，最多报4个，看谁先报到30。这应该是最古老的关于巴什博奕的游戏了吧。</p><p>其实如果知道原理，这游戏一点运气成分都没有，只和先手后手有关，比如第一次报数，A报k个数，那么B报5-k个数，那么B报数之后问题就变为，A和B一块报数，看谁先报到25了，进而变为20,15,10,5，当到5的时候，不管A怎么报数，最后一个数肯定是B报的，可以看出，作为后手的B在个游戏中是不会输的。</p><p>那么如果我们要报n个数，每次最少报一个，最多报m个，我们可以找到这么一个整数k和r，使n=k*(m+1)+r，代入上面的例子我们就可以知道，如果r=0，那么先手必败；否则，先手必胜。</p><p>巴什博奕：只有一堆n个物品，两个人轮流从中取物，规定每次最少取一个，最多取m个，最后取光者为胜。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int n,m;<br>    while(cin&gt;&gt;n&gt;&gt;m)<br>      if(n%(m+1)==0)  cout&lt;&lt;&quot;后手必胜&quot;&lt;&lt;endl;<br>      else cout&lt;&lt;&quot;先手必胜&quot;&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题有：HDU4764  Stone：</p><p>题目大意：Tang和Jiang轮流写数字，Tang先写，每次写的数x满足1&lt;=x&lt;=k，Jiang每次写的数y满足1&lt;=y-x&lt;=k，谁先写到不小于n的数算输。</p><p>结论：r=(n-1)%(k+1)，r=0时Jiang胜，否则Tang胜。</p><h2 id="二-威佐夫博弈（Wythoff-Game）："><a href="#二-威佐夫博弈（Wythoff-Game）：" class="headerlink" title="二.  威佐夫博弈（Wythoff Game）："></a>二.  威佐夫博弈（Wythoff Game）：</h2><p>有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。</p><p>直接说结论了，若两堆物品的初始值为（x，y），且x&lt;y，则另z=y-x；</p><p>记w=(int)[((sqrt(5)+1)/2)*z ]；</p><p>若w=x，则先手必败，否则先手必胜。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int n1,n2,temp;<br>    while(cin&gt;&gt;n1&gt;&gt;n2)<br>    &#123;<br>        if(n1&gt;n2)  swap(n1,n2);<br>        temp=floor((n2-n1)*(1+sqrt(5.0))/2.0);<br>        if(temp==n1) cout&lt;&lt;&quot;后手必胜&quot;&lt;&lt;endl;<br>        else cout&lt;&lt;&quot;先手必胜&quot;&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-尼姆博弈（Nimm-Game）："><a href="#三-尼姆博弈（Nimm-Game）：" class="headerlink" title="三.  尼姆博弈（Nimm Game）："></a>三.  尼姆博弈（Nimm Game）：</h2><p>尼姆博弈指的是这样一个博弈游戏：有任意堆物品，每堆物品的个数是任意的，双方轮流从中取物品，每一次只能从一堆物品中取部分或全部物品，最少取一件，取到最后一件物品的人获胜。</p><p>结论就是：把每堆物品数全部异或起来，如果得到的值为0，那么先手必败，否则先手必胜。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br>&#123;<br>    int n,ans,temp;<br>    while(cin&gt;&gt;n)<br>    &#123;<br>        temp=0;<br>        for(int i=0;i&lt;n;i++)<br>        &#123;<br>            cin&gt;&gt;ans;<br>            temp^=ans;<br>        &#125;<br>        if(temp==0)  cout&lt;&lt;&quot;后手必胜&quot;&lt;&lt;endl;<br>        else cout&lt;&lt;&quot;先手必胜&quot;&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-斐波那契博弈："><a href="#四-斐波那契博弈：" class="headerlink" title="四.  斐波那契博弈："></a>四.  斐波那契博弈：</h2><p>有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。</p><p>结论是：先手胜当且仅当n不是斐波那契数（n为物品总数）</p><p>如HDU2516</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;iostream&gt;  <br>#include &lt;string.h&gt;  <br>#include &lt;stdio.h&gt;  <br>using namespace std;  <br>const int N = 55;    <br>int f[N];   <br>void Init()  <br>&#123;  <br>    f[0] = f[1] = 1;  <br>    for(int i=2;i&lt;N;i++)  <br>        f[i] = f[i-1] + f[i-2];  <br>&#125;    <br>int main()  <br>&#123;  <br>    Init();  <br>    int n;  <br>    while(cin&gt;&gt;n)  <br>    &#123;  <br>        if(n == 0) break;  <br>        bool flag = 0;  <br>        for(int i=0;i&lt;N;i++)  <br>        &#123;  <br>            if(f[i] == n)  <br>            &#123;  <br>                flag = 1;  <br>                break;  <br>            &#125;  <br>        &#125;  <br>        if(flag) puts(&quot;Second win&quot;);  <br>        else     puts(&quot;First win&quot;);  <br>    &#125;  <br>   return 0;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
